(function($) {
	$.color = {};
	$.color.make = function(r, g, b, a) {
		var o = {};
		o.r = r || 0;
		o.g = g || 0;
		o.b = b || 0;
		o.a = a != null ? a : 1;
		o.add = function(c, d) {
			for (var i = 0; i < c.length; ++i) {
				o[c.charAt(i)] += d
			}
			return o.normalize()
		};
		o.scale = function(c, f) {
			for (var i = 0; i < c.length; ++i) {
				o[c.charAt(i)] *= f
			}
			return o.normalize()
		};
		o.toString = function() {
			if (o.a >= 1) {
				return "rgb(" + [ o.r, o.g, o.b ].join(",") + ")"
			} else {
				return "rgba(" + [ o.r, o.g, o.b, o.a ].join(",") + ")"
			}
		};
		o.normalize = function() {
			function clamp(min, value, max) {
				return value < min ? min : value > max ? max : value
			}
			o.r = clamp(0, parseInt(o.r), 255);
			o.g = clamp(0, parseInt(o.g), 255);
			o.b = clamp(0, parseInt(o.b), 255);
			o.a = clamp(0, o.a, 1);
			return o
		};
		o.clone = function() {
			return $.color.make(o.r, o.b, o.g, o.a)
		};
		return o.normalize()
	};
	$.color.extract = function(elem, css) {
		var c;
		do {
			c = elem.css(css).toLowerCase();
			if (c != "" && c != "transparent") {
				break
			}
			elem = elem.parent()
		} while (elem.length && !$.nodeName(elem.get(0), "body"));
		if (c == "rgba(0, 0, 0, 0)") {
			c = "transparent"
		}
		return $.color.parse(c)
	};
	$.color.parse = function(str) {
		var res, m = $.color.make;
		if (res = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/
				.exec(str)) {
			return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(
					res[3], 10))
		}
		if (res = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/
				.exec(str)) {
			return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(
					res[3], 10), parseFloat(res[4]))
		}
		if (res = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/
				.exec(str)) {
			return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55,
					parseFloat(res[3]) * 2.55)
		}
		if (res = /rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/
				.exec(str)) {
			return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55,
					parseFloat(res[3]) * 2.55, parseFloat(res[4]))
		}
		if (res = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str)) {
			return m(parseInt(res[1], 16), parseInt(res[2], 16), parseInt(
					res[3], 16))
		}
		if (res = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str)) {
			return m(parseInt(res[1] + res[1], 16), parseInt(res[2] + res[2],
					16), parseInt(res[3] + res[3], 16))
		}
		var name = $.trim(str).toLowerCase();
		if (name == "transparent") {
			return m(255, 255, 255, 0)
		} else {
			res = lookupColors[name] || [ 0, 0, 0 ];
			return m(res[0], res[1], res[2])
		}
	};
	var lookupColors = {
		aqua : [ 0, 255, 255 ],
		azure : [ 240, 255, 255 ],
		beige : [ 245, 245, 220 ],
		black : [ 0, 0, 0 ],
		blue : [ 0, 0, 255 ],
		brown : [ 165, 42, 42 ],
		cyan : [ 0, 255, 255 ],
		darkblue : [ 0, 0, 139 ],
		darkcyan : [ 0, 139, 139 ],
		darkgrey : [ 169, 169, 169 ],
		darkgreen : [ 0, 100, 0 ],
		darkkhaki : [ 189, 183, 107 ],
		darkmagenta : [ 139, 0, 139 ],
		darkolivegreen : [ 85, 107, 47 ],
		darkorange : [ 255, 140, 0 ],
		darkorchid : [ 153, 50, 204 ],
		darkred : [ 139, 0, 0 ],
		darksalmon : [ 233, 150, 122 ],
		darkviolet : [ 148, 0, 211 ],
		fuchsia : [ 255, 0, 255 ],
		gold : [ 255, 215, 0 ],
		green : [ 0, 128, 0 ],
		indigo : [ 75, 0, 130 ],
		khaki : [ 240, 230, 140 ],
		lightblue : [ 173, 216, 230 ],
		lightcyan : [ 224, 255, 255 ],
		lightgreen : [ 144, 238, 144 ],
		lightgrey : [ 211, 211, 211 ],
		lightpink : [ 255, 182, 193 ],
		lightyellow : [ 255, 255, 224 ],
		lime : [ 0, 255, 0 ],
		magenta : [ 255, 0, 255 ],
		maroon : [ 128, 0, 0 ],
		navy : [ 0, 0, 128 ],
		olive : [ 128, 128, 0 ],
		orange : [ 255, 165, 0 ],
		pink : [ 255, 192, 203 ],
		purple : [ 128, 0, 128 ],
		violet : [ 128, 0, 128 ],
		red : [ 255, 0, 0 ],
		silver : [ 192, 192, 192 ],
		white : [ 255, 255, 255 ],
		yellow : [ 255, 255, 0 ]
	}
})(jQuery);
(function($) {
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function Canvas(cls, container) {
		var element = container.children("." + cls)[0];
		if (element == null) {
			element = document.createElement("canvas");
			element.className = cls;
			$(element).css({
				direction : "ltr",
				position : "absolute",
				left : 0,
				top : 0
			}).appendTo(container);
			if (!element.getContext) {
				if (window.G_vmlCanvasManager) {
					element = window.G_vmlCanvasManager.initElement(element)
				} else {
					throw new Error(
							"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.")
				}
			}
		}
		this.element = element;
		var context = this.context = element.getContext("2d");
		var devicePixelRatio = window.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio
				|| context.mozBackingStorePixelRatio
				|| context.msBackingStorePixelRatio
				|| context.oBackingStorePixelRatio
				|| context.backingStorePixelRatio || 1;
		this.pixelRatio = devicePixelRatio / backingStoreRatio;
		this.resize(container.width(), container.height());
		this.textContainer = null;
		this.text = {};
		this._textCache = {}
	}
	Canvas.prototype.resize = function(width, height) {
		if (width <= 0 || height <= 0) {
			throw new Error("Invalid dimensions for plot, width = " + width
					+ ", height = " + height)
		}
		var element = this.element, context = this.context, pixelRatio = this.pixelRatio;
		if (this.width != width) {
			element.width = width * pixelRatio;
			element.style.width = width + "px";
			this.width = width
		}
		if (this.height != height) {
			element.height = height * pixelRatio;
			element.style.height = height + "px";
			this.height = height
		}
		context.restore();
		context.save();
		context.scale(pixelRatio, pixelRatio)
	};
	Canvas.prototype.clear = function() {
		this.context.clearRect(0, 0, this.width, this.height)
	};
	Canvas.prototype.render = function() {
		var cache = this._textCache;
		for ( var layerKey in cache) {
			if (hasOwnProperty.call(cache, layerKey)) {
				var layer = this.getTextLayer(layerKey), layerCache = cache[layerKey];
				layer.hide();
				for ( var styleKey in layerCache) {
					if (hasOwnProperty.call(layerCache, styleKey)) {
						var styleCache = layerCache[styleKey];
						for ( var key in styleCache) {
							if (hasOwnProperty.call(styleCache, key)) {
								var positions = styleCache[key].positions;
								for (var i = 0, position; position = positions[i]; i++) {
									if (position.active) {
										if (!position.rendered) {
											layer.append(position.element);
											position.rendered = true
										}
									} else {
										positions.splice(i--, 1);
										if (position.rendered) {
											position.element.detach()
										}
									}
								}
								if (positions.length == 0) {
									delete styleCache[key]
								}
							}
						}
					}
				}
				layer.show()
			}
		}
	};
	Canvas.prototype.getTextLayer = function(classes) {
		var layer = this.text[classes];
		if (layer == null) {
			if (this.textContainer == null) {
				this.textContainer = $("<div class='flot-text'></div>").css({
					position : "absolute",
					top : 0,
					left : 0,
					bottom : 0,
					right : 0,
					"font-size" : "smaller",
					color : "#545454"
				}).insertAfter(this.element)
			}
			layer = this.text[classes] = $("<div></div>").addClass(classes)
					.css({
						position : "absolute",
						top : 0,
						left : 0,
						bottom : 0,
						right : 0
					}).appendTo(this.textContainer)
		}
		return layer
	};
	Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {
		var textStyle, layerCache, styleCache, info;
		text = "" + text;
		if (typeof font === "object") {
			textStyle = font.style + " " + font.variant + " " + font.weight
					+ " " + font.size + "px/" + font.lineHeight + "px "
					+ font.family
		} else {
			textStyle = font
		}
		layerCache = this._textCache[layer];
		if (layerCache == null) {
			layerCache = this._textCache[layer] = {}
		}
		styleCache = layerCache[textStyle];
		if (styleCache == null) {
			styleCache = layerCache[textStyle] = {}
		}
		info = styleCache[text];
		if (info == null) {
			var element = $("<div></div>").html(text).css({
				position : "absolute",
				"max-width" : width,
				top : -9999
			}).appendTo(this.getTextLayer(layer));
			if (typeof font === "object") {
				element.css({
					font : textStyle,
					color : font.color
				})
			} else {
				if (typeof font === "string") {
					element.addClass(font)
				}
			}
			info = styleCache[text] = {
				width : element.outerWidth(true),
				height : element.outerHeight(true),
				element : element,
				positions : []
			};
			element.detach()
		}
		return info
	};
	Canvas.prototype.addText = function(layer, x, y, text, font, angle, width,
			halign, valign) {
		var info = this.getTextInfo(layer, text, font, angle, width), positions = info.positions;
		if (halign == "center") {
			x -= info.width / 2
		} else {
			if (halign == "right") {
				x -= info.width
			}
		}
		if (valign == "middle") {
			y -= info.height / 2
		} else {
			if (valign == "bottom") {
				y -= info.height
			}
		}
		for (var i = 0, position; position = positions[i]; i++) {
			if (position.x == x && position.y == y) {
				position.active = true;
				return
			}
		}
		position = {
			active : true,
			rendered : false,
			element : positions.length ? info.element.clone() : info.element,
			x : x,
			y : y
		};
		positions.push(position);
		position.element.css({
			top : Math.round(y),
			left : Math.round(x),
			"text-align" : halign
		})
	};
	Canvas.prototype.removeText = function(layer, x, y, text, font, angle) {
		if (text == null) {
			var layerCache = this._textCache[layer];
			if (layerCache != null) {
				for ( var styleKey in layerCache) {
					if (hasOwnProperty.call(layerCache, styleKey)) {
						var styleCache = layerCache[styleKey];
						for ( var key in styleCache) {
							if (hasOwnProperty.call(styleCache, key)) {
								var positions = styleCache[key].positions;
								for (var i = 0, position; position = positions[i]; i++) {
									position.active = false
								}
							}
						}
					}
				}
			}
		} else {
			var positions = this.getTextInfo(layer, text, font, angle).positions;
			for (var i = 0, position; position = positions[i]; i++) {
				if (position.x == x && position.y == y) {
					position.active = false
				}
			}
		}
	};
	function Plot(placeholder, data_, options_, plugins) {
		var series = [], options = {
			colors : [ "#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed" ],
			legend : {
				show : true,
				noColumns : 1,
				labelFormatter : null,
				labelBoxBorderColor : "#ccc",
				container : null,
				position : "ne",
				margin : 5,
				backgroundColor : null,
				backgroundOpacity : 0.85,
				sorted : null
			},
			xaxis : {
				show : null,
				position : "bottom",
				mode : null,
				font : null,
				color : null,
				tickColor : null,
				transform : null,
				inverseTransform : null,
				min : null,
				max : null,
				autoscaleMargin : null,
				ticks : null,
				tickFormatter : null,
				labelWidth : null,
				labelHeight : null,
				reserveSpace : null,
				tickLength : null,
				alignTicksWithAxis : null,
				tickDecimals : null,
				tickSize : null,
				minTickSize : null
			},
			yaxis : {
				autoscaleMargin : 0.02,
				position : "left"
			},
			xaxes : [],
			yaxes : [],
			series : {
				points : {
					show : false,
					radius : 3,
					lineWidth : 2,
					fill : true,
					fillColor : "#ffffff",
					symbol : "circle"
				},
				lines : {
					lineWidth : 2,
					fill : false,
					fillColor : null,
					steps : false
				},
				bars : {
					show : false,
					lineWidth : 2,
					barWidth : 1,
					fill : true,
					fillColor : null,
					align : "left",
					horizontal : false,
					zero : true
				},
				shadowSize : 3,
				highlightColor : null
			},
			grid : {
				show : true,
				aboveData : false,
				color : "#545454",
				backgroundColor : null,
				borderColor : null,
				tickColor : null,
				margin : 0,
				labelMargin : 5,
				axisMargin : 8,
				borderWidth : 2,
				minBorderMargin : null,
				markings : null,
				markingsColor : "#f4f4f4",
				markingsLineWidth : 2,
				clickable : false,
				hoverable : false,
				autoHighlight : true,
				mouseActiveRadius : 10
			},
			interaction : {
				redrawOverlayInterval : 1000 / 60
			},
			hooks : {}
		}, surface = null, overlay = null, eventHolder = null, ctx = null, octx = null, xaxes = [], yaxes = [], plotOffset = {
			left : 0,
			right : 0,
			top : 0,
			bottom : 0
		}, plotWidth = 0, plotHeight = 0, hooks = {
			processOptions : [],
			processRawData : [],
			processDatapoints : [],
			processOffset : [],
			drawBackground : [],
			drawSeries : [],
			draw : [],
			bindEvents : [],
			drawOverlay : [],
			shutdown : []
		}, plot = this;
		plot.setData = setData;
		plot.setupGrid = setupGrid;
		plot.draw = draw;
		plot.getPlaceholder = function() {
			return placeholder
		};
		plot.getCanvas = function() {
			return surface.element
		};
		plot.getPlotOffset = function() {
			return plotOffset
		};
		plot.width = function() {
			return plotWidth
		};
		plot.height = function() {
			return plotHeight
		};
		plot.offset = function() {
			var o = eventHolder.offset();
			o.left += plotOffset.left;
			o.top += plotOffset.top;
			return o
		};
		plot.getData = function() {
			return series
		};
		plot.getAxes = function() {
			var res = {}, i;
			$.each(xaxes.concat(yaxes),
					function(_, axis) {
						if (axis) {
							res[axis.direction + (axis.n != 1 ? axis.n : "")
									+ "axis"] = axis
						}
					});
			return res
		};
		plot.getXAxes = function() {
			return xaxes
		};
		plot.getYAxes = function() {
			return yaxes
		};
		plot.c2p = canvasToAxisCoords;
		plot.p2c = axisToCanvasCoords;
		plot.getOptions = function() {
			return options
		};
		plot.highlight = highlight;
		plot.unhighlight = unhighlight;
		plot.triggerRedrawOverlay = triggerRedrawOverlay;
		plot.pointOffset = function(point) {
			return {
				left : parseInt(xaxes[axisNumber(point, "x") - 1].p2c(+point.x)
						+ plotOffset.left, 10),
				top : parseInt(yaxes[axisNumber(point, "y") - 1].p2c(+point.y)
						+ plotOffset.top, 10)
			}
		};
		plot.shutdown = shutdown;
		plot.destroy = function() {
			shutdown();
			placeholder.removeData("plot").empty();
			series = [];
			options = null;
			surface = null;
			overlay = null;
			eventHolder = null;
			ctx = null;
			octx = null;
			xaxes = [];
			yaxes = [];
			hooks = null;
			highlights = [];
			plot = null
		};
		plot.resize = function() {
			var width = placeholder.width(), height = placeholder.height();
			surface.resize(width, height);
			overlay.resize(width, height)
		};
		plot.hooks = hooks;
		initPlugins(plot);
		parseOptions(options_);
		setupCanvases();
		setData(data_);
		setupGrid();
		draw();
		bindEvents();
		function executeHooks(hook, args) {
			args = [ plot ].concat(args);
			for (var i = 0; i < hook.length; ++i) {
				hook[i].apply(this, args)
			}
		}
		function initPlugins() {
			var classes = {
				Canvas : Canvas
			};
			for (var i = 0; i < plugins.length; ++i) {
				var p = plugins[i];
				p.init(plot, classes);
				if (p.options) {
					$.extend(true, options, p.options)
				}
			}
		}
		function parseOptions(opts) {
			$.extend(true, options, opts);
			if (opts && opts.colors) {
				options.colors = opts.colors
			}
			if (options.xaxis.color == null) {
				options.xaxis.color = $.color.parse(options.grid.color).scale(
						"a", 0.22).toString()
			}
			if (options.yaxis.color == null) {
				options.yaxis.color = $.color.parse(options.grid.color).scale(
						"a", 0.22).toString()
			}
			if (options.xaxis.tickColor == null) {
				options.xaxis.tickColor = options.grid.tickColor
						|| options.xaxis.color
			}
			if (options.yaxis.tickColor == null) {
				options.yaxis.tickColor = options.grid.tickColor
						|| options.yaxis.color
			}
			if (options.grid.borderColor == null) {
				options.grid.borderColor = options.grid.color
			}
			if (options.grid.tickColor == null) {
				options.grid.tickColor = $.color.parse(options.grid.color)
						.scale("a", 0.22).toString()
			}
			var i, axisOptions, axisCount, fontSize = placeholder
					.css("font-size"), fontSizeDefault = fontSize ? +fontSize
					.replace("px", "") : 13, fontDefaults = {
				style : placeholder.css("font-style"),
				size : Math.round(0.8 * fontSizeDefault),
				variant : placeholder.css("font-variant"),
				weight : placeholder.css("font-weight"),
				family : placeholder.css("font-family")
			};
			axisCount = options.xaxes.length || 1;
			for (i = 0; i < axisCount; ++i) {
				axisOptions = options.xaxes[i];
				if (axisOptions && !axisOptions.tickColor) {
					axisOptions.tickColor = axisOptions.color
				}
				axisOptions = $.extend(true, {}, options.xaxis, axisOptions);
				options.xaxes[i] = axisOptions;
				if (axisOptions.font) {
					axisOptions.font = $.extend({}, fontDefaults,
							axisOptions.font);
					if (!axisOptions.font.color) {
						axisOptions.font.color = axisOptions.color
					}
					if (!axisOptions.font.lineHeight) {
						axisOptions.font.lineHeight = Math
								.round(axisOptions.font.size * 1.15)
					}
				}
			}
			axisCount = options.yaxes.length || 1;
			for (i = 0; i < axisCount; ++i) {
				axisOptions = options.yaxes[i];
				if (axisOptions && !axisOptions.tickColor) {
					axisOptions.tickColor = axisOptions.color
				}
				axisOptions = $.extend(true, {}, options.yaxis, axisOptions);
				options.yaxes[i] = axisOptions;
				if (axisOptions.font) {
					axisOptions.font = $.extend({}, fontDefaults,
							axisOptions.font);
					if (!axisOptions.font.color) {
						axisOptions.font.color = axisOptions.color
					}
					if (!axisOptions.font.lineHeight) {
						axisOptions.font.lineHeight = Math
								.round(axisOptions.font.size * 1.15)
					}
				}
			}
			if (options.xaxis.noTicks && options.xaxis.ticks == null) {
				options.xaxis.ticks = options.xaxis.noTicks
			}
			if (options.yaxis.noTicks && options.yaxis.ticks == null) {
				options.yaxis.ticks = options.yaxis.noTicks
			}
			if (options.x2axis) {
				options.xaxes[1] = $.extend(true, {}, options.xaxis,
						options.x2axis);
				options.xaxes[1].position = "top"
			}
			if (options.y2axis) {
				options.yaxes[1] = $.extend(true, {}, options.yaxis,
						options.y2axis);
				options.yaxes[1].position = "right"
			}
			if (options.grid.coloredAreas) {
				options.grid.markings = options.grid.coloredAreas
			}
			if (options.grid.coloredAreasColor) {
				options.grid.markingsColor = options.grid.coloredAreasColor
			}
			if (options.lines) {
				$.extend(true, options.series.lines, options.lines)
			}
			if (options.points) {
				$.extend(true, options.series.points, options.points)
			}
			if (options.bars) {
				$.extend(true, options.series.bars, options.bars)
			}
			if (options.shadowSize != null) {
				options.series.shadowSize = options.shadowSize
			}
			if (options.highlightColor != null) {
				options.series.highlightColor = options.highlightColor
			}
			for (i = 0; i < options.xaxes.length; ++i) {
				getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i]
			}
			for (i = 0; i < options.yaxes.length; ++i) {
				getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i]
			}
			for ( var n in hooks) {
				if (options.hooks[n] && options.hooks[n].length) {
					hooks[n] = hooks[n].concat(options.hooks[n])
				}
			}
			executeHooks(hooks.processOptions, [ options ])
		}
		function setData(d) {
			series = parseData(d);
			fillInSeriesOptions();
			processData()
		}
		function parseData(d) {
			var res = [];
			for (var i = 0; i < d.length; ++i) {
				var s = $.extend(true, {}, options.series);
				if (d[i].data != null) {
					s.data = d[i].data;
					delete d[i].data;
					$.extend(true, s, d[i]);
					d[i].data = s.data
				} else {
					s.data = d[i]
				}
				res.push(s)
			}
			return res
		}
		function axisNumber(obj, coord) {
			var a = obj[coord + "axis"];
			if (typeof a == "object") {
				a = a.n
			}
			if (typeof a != "number") {
				a = 1
			}
			return a
		}
		function allAxes() {
			return $.grep(xaxes.concat(yaxes), function(a) {
				return a
			})
		}
		function canvasToAxisCoords(pos) {
			var res = {}, i, axis;
			for (i = 0; i < xaxes.length; ++i) {
				axis = xaxes[i];
				if (axis && axis.used) {
					res["x" + axis.n] = axis.c2p(pos.left)
				}
			}
			for (i = 0; i < yaxes.length; ++i) {
				axis = yaxes[i];
				if (axis && axis.used) {
					res["y" + axis.n] = axis.c2p(pos.top)
				}
			}
			if (res.x1 !== undefined) {
				res.x = res.x1
			}
			if (res.y1 !== undefined) {
				res.y = res.y1
			}
			return res
		}
		function axisToCanvasCoords(pos) {
			var res = {}, i, axis, key;
			for (i = 0; i < xaxes.length; ++i) {
				axis = xaxes[i];
				if (axis && axis.used) {
					key = "x" + axis.n;
					if (pos[key] == null && axis.n == 1) {
						key = "x"
					}
					if (pos[key] != null) {
						res.left = axis.p2c(pos[key]);
						break
					}
				}
			}
			for (i = 0; i < yaxes.length; ++i) {
				axis = yaxes[i];
				if (axis && axis.used) {
					key = "y" + axis.n;
					if (pos[key] == null && axis.n == 1) {
						key = "y"
					}
					if (pos[key] != null) {
						res.top = axis.p2c(pos[key]);
						break
					}
				}
			}
			return res
		}
		function getOrCreateAxis(axes, number) {
			if (!axes[number - 1]) {
				axes[number - 1] = {
					n : number,
					direction : axes == xaxes ? "x" : "y",
					options : $.extend(true, {}, axes == xaxes ? options.xaxis
							: options.yaxis)
				}
			}
			return axes[number - 1]
		}
		function fillInSeriesOptions() {
			var neededColors = series.length, maxIndex = -1, i;
			for (i = 0; i < series.length; ++i) {
				var sc = series[i].color;
				if (sc != null) {
					neededColors--;
					if (typeof sc == "number" && sc > maxIndex) {
						maxIndex = sc
					}
				}
			}
			if (neededColors <= maxIndex) {
				neededColors = maxIndex + 1
			}
			var c, colors = [], colorPool = options.colors, colorPoolSize = colorPool.length, variation = 0;
			for (i = 0; i < neededColors; i++) {
				c = $.color.parse(colorPool[i % colorPoolSize] || "#666");
				if (i % colorPoolSize == 0 && i) {
					if (variation >= 0) {
						if (variation < 0.5) {
							variation = -variation - 0.2
						} else {
							variation = 0
						}
					} else {
						variation = -variation
					}
				}
				colors[i] = c.scale("rgb", 1 + variation)
			}
			var colori = 0, s;
			for (i = 0; i < series.length; ++i) {
				s = series[i];
				if (s.color == null) {
					s.color = colors[colori].toString();
					++colori
				} else {
					if (typeof s.color == "number") {
						s.color = colors[s.color].toString()
					}
				}
				if (s.lines.show == null) {
					var v, show = true;
					for (v in s) {
						if (s[v] && s[v].show) {
							show = false;
							break
						}
					}
					if (show) {
						s.lines.show = true
					}
				}
				if (s.lines.zero == null) {
					s.lines.zero = !!s.lines.fill
				}
				s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, "x"));
				s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, "y"))
			}
		}
		function processData() {
			var topSentry = Number.POSITIVE_INFINITY, bottomSentry = Number.NEGATIVE_INFINITY, fakeInfinity = Number.MAX_VALUE, i, j, k, m, length, s, points, ps, x, y, axis, val, f, p, data, format;
			function updateAxis(axis, min, max) {
				if (min < axis.datamin && min != -fakeInfinity) {
					axis.datamin = min
				}
				if (max > axis.datamax && max != fakeInfinity) {
					axis.datamax = max
				}
			}
			$.each(allAxes(), function(_, axis) {
				axis.datamin = topSentry;
				axis.datamax = bottomSentry;
				axis.used = false
			});
			for (i = 0; i < series.length; ++i) {
				s = series[i];
				s.datapoints = {
					points : []
				};
				executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ])
			}
			for (i = 0; i < series.length; ++i) {
				s = series[i];
				data = s.data;
				format = s.datapoints.format;
				if (!format) {
					format = [];
					format.push({
						x : true,
						number : true,
						required : true
					});
					format.push({
						y : true,
						number : true,
						required : true
					});
					if (s.bars.show || (s.lines.show && s.lines.fill)) {
						var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));
						format.push({
							y : true,
							number : true,
							required : false,
							defaultValue : 0,
							autoscale : autoscale
						});
						if (s.bars.horizontal) {
							delete format[format.length - 1].y;
							format[format.length - 1].x = true
						}
					}
					s.datapoints.format = format
				}
				if (s.datapoints.pointsize != null) {
					continue
				}
				s.datapoints.pointsize = format.length;
				ps = s.datapoints.pointsize;
				points = s.datapoints.points;
				var insertSteps = s.lines.show && s.lines.steps;
				s.xaxis.used = s.yaxis.used = true;
				for (j = k = 0; j < data.length; ++j, k += ps) {
					p = data[j];
					var nullify = p == null;
					if (!nullify) {
						for (m = 0; m < ps; ++m) {
							val = p[m];
							f = format[m];
							if (f) {
								if (f.number && val != null) {
									val = +val;
									if (isNaN(val)) {
										val = null
									} else {
										if (val == Infinity) {
											val = fakeInfinity
										} else {
											if (val == -Infinity) {
												val = -fakeInfinity
											}
										}
									}
								}
								if (val == null) {
									if (f.required) {
										nullify = true
									}
									if (f.defaultValue != null) {
										val = f.defaultValue
									}
								}
							}
							points[k + m] = val
						}
					}
					if (nullify) {
						for (m = 0; m < ps; ++m) {
							val = points[k + m];
							if (val != null) {
								f = format[m];
								if (f.autoscale !== false) {
									if (f.x) {
										updateAxis(s.xaxis, val, val)
									}
									if (f.y) {
										updateAxis(s.yaxis, val, val)
									}
								}
							}
							points[k + m] = null
						}
					} else {
						if (insertSteps && k > 0 && points[k - ps] != null
								&& points[k - ps] != points[k]
								&& points[k - ps + 1] != points[k + 1]) {
							for (m = 0; m < ps; ++m) {
								points[k + ps + m] = points[k + m]
							}
							points[k + 1] = points[k - ps + 1];
							k += ps
						}
					}
				}
			}
			for (i = 0; i < series.length; ++i) {
				s = series[i];
				executeHooks(hooks.processDatapoints, [ s, s.datapoints ])
			}
			for (i = 0; i < series.length; ++i) {
				s = series[i];
				points = s.datapoints.points;
				ps = s.datapoints.pointsize;
				format = s.datapoints.format;
				var xmin = topSentry, ymin = topSentry, xmax = bottomSentry, ymax = bottomSentry;
				for (j = 0; j < points.length; j += ps) {
					if (points[j] == null) {
						continue
					}
					for (m = 0; m < ps; ++m) {
						val = points[j + m];
						f = format[m];
						if (!f || f.autoscale === false || val == fakeInfinity
								|| val == -fakeInfinity) {
							continue
						}
						if (f.x) {
							if (val < xmin) {
								xmin = val
							}
							if (val > xmax) {
								xmax = val
							}
						}
						if (f.y) {
							if (val < ymin) {
								ymin = val
							}
							if (val > ymax) {
								ymax = val
							}
						}
					}
				}
				if (s.bars.show) {
					var delta;
					switch (s.bars.align) {
					case "left":
						delta = 0;
						break;
					case "right":
						delta = -s.bars.barWidth;
						break;
					default:
						delta = -s.bars.barWidth / 2
					}
					if (s.bars.horizontal) {
						ymin += delta;
						ymax += delta + s.bars.barWidth
					} else {
						xmin += delta;
						xmax += delta + s.bars.barWidth
					}
				}
				updateAxis(s.xaxis, xmin, xmax);
				updateAxis(s.yaxis, ymin, ymax)
			}
			$.each(allAxes(), function(_, axis) {
				if (axis.datamin == topSentry) {
					axis.datamin = null
				}
				if (axis.datamax == bottomSentry) {
					axis.datamax = null
				}
			})
		}
		function setupCanvases() {
			placeholder.css("padding", 0).children().filter(
					function() {
						return !$(this).hasClass("flot-overlay")
								&& !$(this).hasClass("flot-base")
					}).remove();
			if (placeholder.css("position") == "static") {
				placeholder.css("position", "relative")
			}
			surface = new Canvas("flot-base", placeholder);
			overlay = new Canvas("flot-overlay", placeholder);
			ctx = surface.context;
			octx = overlay.context;
			eventHolder = $(overlay.element).unbind();
			var existing = placeholder.data("plot");
			if (existing) {
				existing.shutdown();
				overlay.clear()
			}
			placeholder.data("plot", plot)
		}
		function bindEvents() {
			if (options.grid.hoverable) {
				eventHolder.mousemove(onMouseMove);
				eventHolder.bind("mouseleave", onMouseLeave)
			}
			if (options.grid.clickable) {
				eventHolder.click(onClick)
			}
			executeHooks(hooks.bindEvents, [ eventHolder ])
		}
		function shutdown() {
			if (redrawTimeout) {
				clearTimeout(redrawTimeout)
			}
			eventHolder.unbind("mousemove", onMouseMove);
			eventHolder.unbind("mouseleave", onMouseLeave);
			eventHolder.unbind("click", onClick);
			executeHooks(hooks.shutdown, [ eventHolder ])
		}
		function setTransformationHelpers(axis) {
			function identity(x) {
				return x
			}
			var s, m, t = axis.options.transform || identity, it = axis.options.inverseTransform;
			if (axis.direction == "x") {
				s = axis.scale = plotWidth
						/ Math.abs(t(axis.max) - t(axis.min));
				m = Math.min(t(axis.max), t(axis.min))
			} else {
				s = axis.scale = plotHeight
						/ Math.abs(t(axis.max) - t(axis.min));
				s = -s;
				m = Math.max(t(axis.max), t(axis.min))
			}
			if (t == identity) {
				axis.p2c = function(p) {
					return (p - m) * s
				}
			} else {
				axis.p2c = function(p) {
					return (t(p) - m) * s
				}
			}
			if (!it) {
				axis.c2p = function(c) {
					return m + c / s
				}
			} else {
				axis.c2p = function(c) {
					return it(m + c / s)
				}
			}
		}
		function measureTickLabels(axis) {
			var opts = axis.options, ticks = axis.ticks || [], labelWidth = opts.labelWidth || 0, labelHeight = opts.labelHeight || 0, maxWidth = labelWidth
					|| (axis.direction == "x" ? Math.floor(surface.width
							/ (ticks.length || 1)) : null), legacyStyles = axis.direction
					+ "Axis " + axis.direction + axis.n + "Axis", layer = "flot-"
					+ axis.direction
					+ "-axis flot-"
					+ axis.direction
					+ axis.n
					+ "-axis " + legacyStyles, font = opts.font
					|| "flot-tick-label tickLabel";
			for (var i = 0; i < ticks.length; ++i) {
				var t = ticks[i];
				if (!t.label) {
					continue
				}
				var info = surface.getTextInfo(layer, t.label, font, null,
						maxWidth);
				labelWidth = Math.max(labelWidth, info.width);
				labelHeight = Math.max(labelHeight, info.height)
			}
			axis.labelWidth = opts.labelWidth || labelWidth;
			axis.labelHeight = opts.labelHeight || labelHeight
		}
		function allocateAxisBoxFirstPhase(axis) {
			var lw = axis.labelWidth, lh = axis.labelHeight, pos = axis.options.position, isXAxis = axis.direction === "x", tickLength = axis.options.tickLength, axisMargin = options.grid.axisMargin, padding = options.grid.labelMargin, innermost = true, outermost = true, first = true, found = false;
			$.each(isXAxis ? xaxes : yaxes, function(i, a) {
				if (a && a.reserveSpace) {
					if (a === axis) {
						found = true
					} else {
						if (a.options.position === pos) {
							if (found) {
								outermost = false
							} else {
								innermost = false
							}
						}
					}
					if (!found) {
						first = false
					}
				}
			});
			if (outermost) {
				axisMargin = 0
			}
			if (tickLength == null) {
				tickLength = first ? "full" : 5
			}
			if (!isNaN(+tickLength)) {
				padding += +tickLength
			}
			if (isXAxis) {
				lh += padding;
				if (pos == "bottom") {
					plotOffset.bottom += lh + axisMargin;
					axis.box = {
						top : surface.height - plotOffset.bottom,
						height : lh
					}
				} else {
					axis.box = {
						top : plotOffset.top + axisMargin,
						height : lh
					};
					plotOffset.top += lh + axisMargin
				}
			} else {
				lw += padding;
				if (pos == "left") {
					axis.box = {
						left : plotOffset.left + axisMargin,
						width : lw
					};
					plotOffset.left += lw + axisMargin
				} else {
					plotOffset.right += lw + axisMargin;
					axis.box = {
						left : surface.width - plotOffset.right,
						width : lw
					}
				}
			}
			axis.position = pos;
			axis.tickLength = tickLength;
			axis.box.padding = padding;
			axis.innermost = innermost
		}
		function allocateAxisBoxSecondPhase(axis) {
			if (axis.direction == "x") {
				axis.box.left = plotOffset.left - axis.labelWidth / 2;
				axis.box.width = surface.width - plotOffset.left
						- plotOffset.right + axis.labelWidth
			} else {
				axis.box.top = plotOffset.top - axis.labelHeight / 2;
				axis.box.height = surface.height - plotOffset.bottom
						- plotOffset.top + axis.labelHeight
			}
		}
		function adjustLayoutForThingsStickingOut() {
			var minMargin = options.grid.minBorderMargin, axis, i;
			if (minMargin == null) {
				minMargin = 0;
				for (i = 0; i < series.length; ++i) {
					minMargin = Math
							.max(
									minMargin,
									2 * (series[i].points.radius + series[i].points.lineWidth / 2))
				}
			}
			var margins = {
				left : minMargin,
				right : minMargin,
				top : minMargin,
				bottom : minMargin
			};
			$.each(allAxes(), function(_, axis) {
				if (axis.reserveSpace && axis.ticks && axis.ticks.length) {
					var lastTick = axis.ticks[axis.ticks.length - 1];
					if (axis.direction === "x") {
						margins.left = Math.max(margins.left,
								axis.labelWidth / 2);
						if (lastTick.v <= axis.max) {
							margins.right = Math.max(margins.right,
									axis.labelWidth / 2)
						}
					} else {
						margins.bottom = Math.max(margins.bottom,
								axis.labelHeight / 2);
						if (lastTick.v <= axis.max) {
							margins.top = Math.max(margins.top,
									axis.labelHeight / 2)
						}
					}
				}
			});
			plotOffset.left = Math
					.ceil(Math.max(margins.left, plotOffset.left));
			plotOffset.right = Math.ceil(Math.max(margins.right,
					plotOffset.right));
			plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));
			plotOffset.bottom = Math.ceil(Math.max(margins.bottom,
					plotOffset.bottom))
		}
		function setupGrid() {
			var i, axes = allAxes(), showGrid = options.grid.show;
			for ( var a in plotOffset) {
				var margin = options.grid.margin || 0;
				plotOffset[a] = typeof margin == "number" ? margin
						: margin[a] || 0
			}
			executeHooks(hooks.processOffset, [ plotOffset ]);
			for ( var a in plotOffset) {
				if (typeof (options.grid.borderWidth) == "object") {
					plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0
				} else {
					plotOffset[a] += showGrid ? options.grid.borderWidth : 0
				}
			}
			$.each(axes, function(_, axis) {
				axis.show = axis.options.show;
				if (axis.show == null) {
					axis.show = axis.used
				}
				axis.reserveSpace = axis.show || axis.options.reserveSpace;
				setRange(axis)
			});
			if (showGrid) {
				var allocatedAxes = $.grep(axes, function(axis) {
					return axis.reserveSpace
				});
				$.each(allocatedAxes, function(_, axis) {
					setupTickGeneration(axis);
					setTicks(axis);
					snapRangeToTicks(axis, axis.ticks);
					measureTickLabels(axis)
				});
				for (i = allocatedAxes.length - 1; i >= 0; --i) {
					allocateAxisBoxFirstPhase(allocatedAxes[i])
				}
				adjustLayoutForThingsStickingOut();
				$.each(allocatedAxes, function(_, axis) {
					allocateAxisBoxSecondPhase(axis)
				})
			}
			plotWidth = surface.width - plotOffset.left - plotOffset.right;
			plotHeight = surface.height - plotOffset.bottom - plotOffset.top;
			$.each(axes, function(_, axis) {
				setTransformationHelpers(axis)
			});
			if (showGrid) {
				drawAxisLabels()
			}
			insertLegend()
		}
		function setRange(axis) {
			var opts = axis.options, min = +(opts.min != null ? opts.min
					: axis.datamin), max = +(opts.max != null ? opts.max
					: axis.datamax), delta = max - min;
			if (delta == 0) {
				var widen = max == 0 ? 1 : 0.01;
				if (opts.min == null) {
					min -= widen
				}
				if (opts.max == null || opts.min != null) {
					max += widen
				}
			} else {
				var margin = opts.autoscaleMargin;
				if (margin != null) {
					if (opts.min == null) {
						min -= delta * margin;
						if (min < 0 && axis.datamin != null
								&& axis.datamin >= 0) {
							min = 0
						}
					}
					if (opts.max == null) {
						max += delta * margin;
						if (max > 0 && axis.datamax != null
								&& axis.datamax <= 0) {
							max = 0
						}
					}
				}
			}
			axis.min = min;
			axis.max = max
		}
		function setupTickGeneration(axis) {
			var opts = axis.options;
			var noTicks;
			if (typeof opts.ticks == "number" && opts.ticks > 0) {
				noTicks = opts.ticks
			} else {
				noTicks = 0.3 * Math.sqrt(axis.direction == "x" ? surface.width
						: surface.height)
			}
			var delta = (axis.max - axis.min) / noTicks, dec = -Math.floor(Math
					.log(delta)
					/ Math.LN10), maxDec = opts.tickDecimals;
			if (maxDec != null && dec > maxDec) {
				dec = maxDec
			}
			var magn = Math.pow(10, -dec), norm = delta / magn, size;
			if (norm < 1.5) {
				size = 1
			} else {
				if (norm < 3) {
					size = 2;
					if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {
						size = 2.5;
						++dec
					}
				} else {
					if (norm < 7.5) {
						size = 5
					} else {
						size = 10
					}
				}
			}
			size *= magn;
			if (opts.minTickSize != null && size < opts.minTickSize) {
				size = opts.minTickSize
			}
			axis.delta = delta;
			axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);
			axis.tickSize = opts.tickSize || size;
			if (opts.mode == "time" && !axis.tickGenerator) {
				throw new Error("Time mode requires the flot.time plugin.")
			}
			if (!axis.tickGenerator) {
				axis.tickGenerator = function(axis) {
					var ticks = [], start = floorInBase(axis.min, axis.tickSize), i = 0, v = Number.NaN, prev;
					do {
						prev = v;
						v = start + i * axis.tickSize;
						ticks.push(v);
						++i
					} while (v < axis.max && v != prev);
					return ticks
				};
				axis.tickFormatter = function(value, axis) {
					var factor = axis.tickDecimals ? Math.pow(10,
							axis.tickDecimals) : 1;
					var formatted = "" + Math.round(value * factor) / factor;
					if (axis.tickDecimals != null) {
						var decimal = formatted.indexOf(".");
						var precision = decimal == -1 ? 0 : formatted.length
								- decimal - 1;
						if (precision < axis.tickDecimals) {
							return (precision ? formatted : formatted + ".")
									+ ("" + factor).substr(1, axis.tickDecimals
											- precision)
						}
					}
					return formatted
				}
			}
			if ($.isFunction(opts.tickFormatter)) {
				axis.tickFormatter = function(v, axis) {
					return "" + opts.tickFormatter(v, axis)
				}
			}
			if (opts.alignTicksWithAxis != null) {
				var otherAxis = (axis.direction == "x" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];
				if (otherAxis && otherAxis.used && otherAxis != axis) {
					var niceTicks = axis.tickGenerator(axis);
					if (niceTicks.length > 0) {
						if (opts.min == null) {
							axis.min = Math.min(axis.min, niceTicks[0])
						}
						if (opts.max == null && niceTicks.length > 1) {
							axis.max = Math.max(axis.max,
									niceTicks[niceTicks.length - 1])
						}
					}
					axis.tickGenerator = function(axis) {
						var ticks = [], v, i;
						for (i = 0; i < otherAxis.ticks.length; ++i) {
							v = (otherAxis.ticks[i].v - otherAxis.min)
									/ (otherAxis.max - otherAxis.min);
							v = axis.min + v * (axis.max - axis.min);
							ticks.push(v)
						}
						return ticks
					};
					if (!axis.mode && opts.tickDecimals == null) {
						var extraDec = Math.max(0, -Math.floor(Math
								.log(axis.delta)
								/ Math.LN10) + 1), ts = axis
								.tickGenerator(axis);
						if (!(ts.length > 1 && /\..*0$/.test((ts[1] - ts[0])
								.toFixed(extraDec)))) {
							axis.tickDecimals = extraDec
						}
					}
				}
			}
		}
		function setTicks(axis) {
			var oticks = axis.options.ticks, ticks = [];
			if (oticks == null || (typeof oticks == "number" && oticks > 0)) {
				ticks = axis.tickGenerator(axis)
			} else {
				if (oticks) {
					if ($.isFunction(oticks)) {
						ticks = oticks(axis)
					} else {
						ticks = oticks
					}
				}
			}
			var i, v;
			axis.ticks = [];
			for (i = 0; i < ticks.length; ++i) {
				var label = null;
				var t = ticks[i];
				if (typeof t == "object") {
					v = +t[0];
					if (t.length > 1) {
						label = t[1]
					}
				} else {
					v = +t
				}
				if (label == null) {
					label = axis.tickFormatter(v, axis)
				}
				if (!isNaN(v)) {
					axis.ticks.push({
						v : v,
						label : label
					})
				}
			}
		}
		function snapRangeToTicks(axis, ticks) {
			if (axis.options.autoscaleMargin && ticks.length > 0) {
				if (axis.options.min == null) {
					axis.min = Math.min(axis.min, ticks[0].v)
				}
				if (axis.options.max == null && ticks.length > 1) {
					axis.max = Math.max(axis.max, ticks[ticks.length - 1].v)
				}
			}
		}
		function draw() {
			surface.clear();
			executeHooks(hooks.drawBackground, [ ctx ]);
			var grid = options.grid;
			if (grid.show && grid.backgroundColor) {
				drawBackground()
			}
			if (grid.show && !grid.aboveData) {
				drawGrid()
			}
			for (var i = 0; i < series.length; ++i) {
				executeHooks(hooks.drawSeries, [ ctx, series[i] ]);
				drawSeries(series[i])
			}
			executeHooks(hooks.draw, [ ctx ]);
			if (grid.show && grid.aboveData) {
				drawGrid()
			}
			surface.render();
			triggerRedrawOverlay()
		}
		function extractRange(ranges, coord) {
			var axis, from, to, key, axes = allAxes();
			for (var i = 0; i < axes.length; ++i) {
				axis = axes[i];
				if (axis.direction == coord) {
					key = coord + axis.n + "axis";
					if (!ranges[key] && axis.n == 1) {
						key = coord + "axis"
					}
					if (ranges[key]) {
						from = ranges[key].from;
						to = ranges[key].to;
						break
					}
				}
			}
			if (!ranges[key]) {
				axis = coord == "x" ? xaxes[0] : yaxes[0];
				from = ranges[coord + "1"];
				to = ranges[coord + "2"]
			}
			if (from != null && to != null && from > to) {
				var tmp = from;
				from = to;
				to = tmp
			}
			return {
				from : from,
				to : to,
				axis : axis
			}
		}
		function drawBackground() {
			ctx.save();
			ctx.translate(plotOffset.left, plotOffset.top);
			ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor,
					plotHeight, 0, "rgba(255, 255, 255, 0)");
			ctx.fillRect(0, 0, plotWidth, plotHeight);
			ctx.restore()
		}
		function drawGrid() {
			var i, axes, bw, bc;
			ctx.save();
			ctx.translate(plotOffset.left, plotOffset.top);
			var markings = options.grid.markings;
			if (markings) {
				if ($.isFunction(markings)) {
					axes = plot.getAxes();
					axes.xmin = axes.xaxis.min;
					axes.xmax = axes.xaxis.max;
					axes.ymin = axes.yaxis.min;
					axes.ymax = axes.yaxis.max;
					markings = markings(axes)
				}
				for (i = 0; i < markings.length; ++i) {
					var m = markings[i], xrange = extractRange(m, "x"), yrange = extractRange(
							m, "y");
					if (xrange.from == null) {
						xrange.from = xrange.axis.min
					}
					if (xrange.to == null) {
						xrange.to = xrange.axis.max
					}
					if (yrange.from == null) {
						yrange.from = yrange.axis.min
					}
					if (yrange.to == null) {
						yrange.to = yrange.axis.max
					}
					if (xrange.to < xrange.axis.min
							|| xrange.from > xrange.axis.max
							|| yrange.to < yrange.axis.min
							|| yrange.from > yrange.axis.max) {
						continue
					}
					xrange.from = Math.max(xrange.from, xrange.axis.min);
					xrange.to = Math.min(xrange.to, xrange.axis.max);
					yrange.from = Math.max(yrange.from, yrange.axis.min);
					yrange.to = Math.min(yrange.to, yrange.axis.max);
					if (xrange.from == xrange.to && yrange.from == yrange.to) {
						continue
					}
					xrange.from = xrange.axis.p2c(xrange.from);
					xrange.to = xrange.axis.p2c(xrange.to);
					yrange.from = yrange.axis.p2c(yrange.from);
					yrange.to = yrange.axis.p2c(yrange.to);
					if (xrange.from == xrange.to || yrange.from == yrange.to) {
						ctx.beginPath();
						ctx.strokeStyle = m.color || options.grid.markingsColor;
						ctx.lineWidth = m.lineWidth
								|| options.grid.markingsLineWidth;
						ctx.moveTo(xrange.from, yrange.from);
						ctx.lineTo(xrange.to, yrange.to);
						ctx.stroke()
					} else {
						ctx.fillStyle = m.color || options.grid.markingsColor;
						ctx.fillRect(xrange.from, yrange.to, xrange.to
								- xrange.from, yrange.from - yrange.to)
					}
				}
			}
			axes = allAxes();
			bw = options.grid.borderWidth;
			for (var j = 0; j < axes.length; ++j) {
				var axis = axes[j], box = axis.box, t = axis.tickLength, x, y, xoff, yoff;
				if (!axis.show || axis.ticks.length == 0) {
					continue
				}
				ctx.lineWidth = 1;
				if (axis.direction == "x") {
					x = 0;
					if (t == "full") {
						y = (axis.position == "top" ? 0 : plotHeight)
					} else {
						y = box.top - plotOffset.top
								+ (axis.position == "top" ? box.height : 0)
					}
				} else {
					y = 0;
					if (t == "full") {
						x = (axis.position == "left" ? 0 : plotWidth)
					} else {
						x = box.left - plotOffset.left
								+ (axis.position == "left" ? box.width : 0)
					}
				}
				if (!axis.innermost) {
					ctx.strokeStyle = axis.options.color;
					ctx.beginPath();
					xoff = yoff = 0;
					if (axis.direction == "x") {
						xoff = plotWidth + 1
					} else {
						yoff = plotHeight + 1
					}
					if (ctx.lineWidth == 1) {
						if (axis.direction == "x") {
							y = Math.floor(y) + 0.5
						} else {
							x = Math.floor(x) + 0.5
						}
					}
					ctx.moveTo(x, y);
					ctx.lineTo(x + xoff, y + yoff);
					ctx.stroke()
				}
				ctx.strokeStyle = axis.options.tickColor;
				ctx.beginPath();
				for (i = 0; i < axis.ticks.length; ++i) {
					var v = axis.ticks[i].v;
					xoff = yoff = 0;
					if (isNaN(v)
							|| v < axis.min
							|| v > axis.max
							|| (t == "full"
									&& ((typeof bw == "object" && bw[axis.position] > 0) || bw > 0) && (v == axis.min || v == axis.max))) {
						continue
					}
					if (axis.direction == "x") {
						x = axis.p2c(v);
						yoff = t == "full" ? -plotHeight : t;
						if (axis.position == "top") {
							yoff = -yoff
						}
					} else {
						y = axis.p2c(v);
						xoff = t == "full" ? -plotWidth : t;
						if (axis.position == "left") {
							xoff = -xoff
						}
					}
					if (ctx.lineWidth == 1) {
						if (axis.direction == "x") {
							x = Math.floor(x) + 0.5
						} else {
							y = Math.floor(y) + 0.5
						}
					}
					ctx.moveTo(x, y);
					ctx.lineTo(x + xoff, y + yoff)
				}
				ctx.stroke()
			}
			if (bw) {
				bc = options.grid.borderColor;
				if (typeof bw == "object" || typeof bc == "object") {
					if (typeof bw !== "object") {
						bw = {
							top : bw,
							right : bw,
							bottom : bw,
							left : bw
						}
					}
					if (typeof bc !== "object") {
						bc = {
							top : bc,
							right : bc,
							bottom : bc,
							left : bc
						}
					}
					if (bw.top > 0) {
						ctx.strokeStyle = bc.top;
						ctx.lineWidth = bw.top;
						ctx.beginPath();
						ctx.moveTo(0 - bw.left, 0 - bw.top / 2);
						ctx.lineTo(plotWidth, 0 - bw.top / 2);
						ctx.stroke()
					}
					if (bw.right > 0) {
						ctx.strokeStyle = bc.right;
						ctx.lineWidth = bw.right;
						ctx.beginPath();
						ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);
						ctx.lineTo(plotWidth + bw.right / 2, plotHeight);
						ctx.stroke()
					}
					if (bw.bottom > 0) {
						ctx.strokeStyle = bc.bottom;
						ctx.lineWidth = bw.bottom;
						ctx.beginPath();
						ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom
								/ 2);
						ctx.lineTo(0, plotHeight + bw.bottom / 2);
						ctx.stroke()
					}
					if (bw.left > 0) {
						ctx.strokeStyle = bc.left;
						ctx.lineWidth = bw.left;
						ctx.beginPath();
						ctx.moveTo(0 - bw.left / 2, plotHeight + bw.bottom);
						ctx.lineTo(0 - bw.left / 2, 0);
						ctx.stroke()
					}
				} else {
					ctx.lineWidth = bw;
					ctx.strokeStyle = options.grid.borderColor;
					ctx.strokeRect(-bw / 2, -bw / 2, plotWidth + bw, plotHeight
							+ bw)
				}
			}
			ctx.restore()
		}
		function drawAxisLabels() {
			$
					.each(
							allAxes(),
							function(_, axis) {
								var box = axis.box, legacyStyles = axis.direction
										+ "Axis "
										+ axis.direction
										+ axis.n
										+ "Axis", layer = "flot-"
										+ axis.direction + "-axis flot-"
										+ axis.direction + axis.n + "-axis "
										+ legacyStyles, font = axis.options.font
										|| "flot-tick-label tickLabel", tick, x, y, halign, valign;
								surface.removeText(layer);
								if (!axis.show || axis.ticks.length == 0) {
									return
								}
								for (var i = 0; i < axis.ticks.length; ++i) {
									tick = axis.ticks[i];
									if (!tick.label || tick.v < axis.min
											|| tick.v > axis.max) {
										continue
									}
									if (axis.direction == "x") {
										halign = "center";
										x = plotOffset.left + axis.p2c(tick.v);
										if (axis.position == "bottom") {
											y = box.top + box.padding
										} else {
											y = box.top + box.height
													- box.padding;
											valign = "bottom"
										}
									} else {
										valign = "middle";
										y = plotOffset.top + axis.p2c(tick.v);
										if (axis.position == "left") {
											x = box.left + box.width
													- box.padding;
											halign = "right"
										} else {
											x = box.left + box.padding
										}
									}
									surface.addText(layer, x, y, tick.label,
											font, null, null, halign, valign)
								}
							})
		}
		function drawSeries(series) {
			if (series.lines.show) {
				drawSeriesLines(series)
			}
			if (series.bars.show) {
				drawSeriesBars(series)
			}
			if (series.points.show) {
				drawSeriesPoints(series)
			}
		}
		function drawSeriesLines(series) {
			function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {
				var points = datapoints.points, ps = datapoints.pointsize, prevx = null, prevy = null;
				ctx.beginPath();
				for (var i = ps; i < points.length; i += ps) {
					var x1 = points[i - ps], y1 = points[i - ps + 1], x2 = points[i], y2 = points[i + 1];
					if (x1 == null || x2 == null) {
						continue
					}
					if (y1 <= y2 && y1 < axisy.min) {
						if (y2 < axisy.min) {
							continue
						}
						x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
						y1 = axisy.min
					} else {
						if (y2 <= y1 && y2 < axisy.min) {
							if (y1 < axisy.min) {
								continue
							}
							x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
							y2 = axisy.min
						}
					}
					if (y1 >= y2 && y1 > axisy.max) {
						if (y2 > axisy.max) {
							continue
						}
						x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
						y1 = axisy.max
					} else {
						if (y2 >= y1 && y2 > axisy.max) {
							if (y1 > axisy.max) {
								continue
							}
							x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
							y2 = axisy.max
						}
					}
					if (x1 <= x2 && x1 < axisx.min) {
						if (x2 < axisx.min) {
							continue
						}
						y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
						x1 = axisx.min
					} else {
						if (x2 <= x1 && x2 < axisx.min) {
							if (x1 < axisx.min) {
								continue
							}
							y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
							x2 = axisx.min
						}
					}
					if (x1 >= x2 && x1 > axisx.max) {
						if (x2 > axisx.max) {
							continue
						}
						y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
						x1 = axisx.max
					} else {
						if (x2 >= x1 && x2 > axisx.max) {
							if (x1 > axisx.max) {
								continue
							}
							y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
							x2 = axisx.max
						}
					}
					if (x1 != prevx || y1 != prevy) {
						ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1)
								+ yoffset)
					}
					prevx = x2;
					prevy = y2;
					ctx
							.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2)
									+ yoffset)
				}
				ctx.stroke()
			}
			function plotLineArea(datapoints, axisx, axisy) {
				var points = datapoints.points, ps = datapoints.pointsize, bottom = Math
						.min(Math.max(0, axisy.min), axisy.max), i = 0, top, areaOpen = false, ypos = 1, segmentStart = 0, segmentEnd = 0;
				while (true) {
					if (ps > 0 && i > points.length + ps) {
						break
					}
					i += ps;
					var x1 = points[i - ps], y1 = points[i - ps + ypos], x2 = points[i], y2 = points[i
							+ ypos];
					if (areaOpen) {
						if (ps > 0 && x1 != null && x2 == null) {
							segmentEnd = i;
							ps = -ps;
							ypos = 2;
							continue
						}
						if (ps < 0 && i == segmentStart + ps) {
							ctx.fill();
							areaOpen = false;
							ps = -ps;
							ypos = 1;
							i = segmentStart = segmentEnd + ps;
							continue
						}
					}
					if (x1 == null || x2 == null) {
						continue
					}
					if (x1 <= x2 && x1 < axisx.min) {
						if (x2 < axisx.min) {
							continue
						}
						y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
						x1 = axisx.min
					} else {
						if (x2 <= x1 && x2 < axisx.min) {
							if (x1 < axisx.min) {
								continue
							}
							y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;
							x2 = axisx.min
						}
					}
					if (x1 >= x2 && x1 > axisx.max) {
						if (x2 > axisx.max) {
							continue
						}
						y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
						x1 = axisx.max
					} else {
						if (x2 >= x1 && x2 > axisx.max) {
							if (x1 > axisx.max) {
								continue
							}
							y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;
							x2 = axisx.max
						}
					}
					if (!areaOpen) {
						ctx.beginPath();
						ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));
						areaOpen = true
					}
					if (y1 >= axisy.max && y2 >= axisy.max) {
						ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));
						ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));
						continue
					} else {
						if (y1 <= axisy.min && y2 <= axisy.min) {
							ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));
							ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));
							continue
						}
					}
					var x1old = x1, x2old = x2;
					if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {
						x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
						y1 = axisy.min
					} else {
						if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {
							x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;
							y2 = axisy.min
						}
					}
					if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {
						x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
						y1 = axisy.max
					} else {
						if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {
							x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;
							y2 = axisy.max
						}
					}
					if (x1 != x1old) {
						ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1))
					}
					ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));
					ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
					if (x2 != x2old) {
						ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));
						ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2))
					}
				}
			}
			ctx.save();
			ctx.translate(plotOffset.left, plotOffset.top);
			ctx.lineJoin = "round";
			var lw = series.lines.lineWidth, sw = series.shadowSize;
			if (lw > 0 && sw > 0) {
				ctx.lineWidth = sw;
				ctx.strokeStyle = "rgba(0,0,0,0.1)";
				var angle = Math.PI / 18;
				plotLine(series.datapoints,
						Math.sin(angle) * (lw / 2 + sw / 2), Math.cos(angle)
								* (lw / 2 + sw / 2), series.xaxis, series.yaxis);
				ctx.lineWidth = sw / 2;
				plotLine(series.datapoints,
						Math.sin(angle) * (lw / 2 + sw / 4), Math.cos(angle)
								* (lw / 2 + sw / 4), series.xaxis, series.yaxis)
			}
			ctx.lineWidth = lw;
			ctx.strokeStyle = series.color;
			var fillStyle = getFillStyle(series.lines, series.color, 0,
					plotHeight);
			if (fillStyle) {
				ctx.fillStyle = fillStyle;
				plotLineArea(series.datapoints, series.xaxis, series.yaxis)
			}
			if (lw > 0) {
				plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis)
			}
			ctx.restore()
		}
		function drawSeriesPoints(series) {
			function plotPoints(datapoints, radius, fillStyle, offset, shadow,
					axisx, axisy, symbol) {
				var points = datapoints.points, ps = datapoints.pointsize;
				for (var i = 0; i < points.length; i += ps) {
					var x = points[i], y = points[i + 1];
					if (x == null || x < axisx.min || x > axisx.max
							|| y < axisy.min || y > axisy.max) {
						continue
					}
					ctx.beginPath();
					x = axisx.p2c(x);
					y = axisy.p2c(y) + offset;
					if (symbol == "circle") {
						ctx.arc(x, y, radius, 0,
								shadow ? Math.PI : Math.PI * 2, false)
					} else {
						symbol(ctx, x, y, radius, shadow)
					}
					ctx.closePath();
					if (fillStyle) {
						ctx.fillStyle = fillStyle;
						ctx.fill()
					}
					ctx.stroke()
				}
			}
			ctx.save();
			ctx.translate(plotOffset.left, plotOffset.top);
			var lw = series.points.lineWidth, sw = series.shadowSize, radius = series.points.radius, symbol = series.points.symbol;
			if (lw == 0) {
				lw = 0.0001
			}
			if (lw > 0 && sw > 0) {
				var w = sw / 2;
				ctx.lineWidth = w;
				ctx.strokeStyle = "rgba(0,0,0,0.1)";
				plotPoints(series.datapoints, radius, null, w + w / 2, true,
						series.xaxis, series.yaxis, symbol);
				ctx.strokeStyle = "rgba(0,0,0,0.2)";
				plotPoints(series.datapoints, radius, null, w / 2, true,
						series.xaxis, series.yaxis, symbol)
			}
			ctx.lineWidth = lw;
			ctx.strokeStyle = series.color;
			plotPoints(series.datapoints, radius, getFillStyle(series.points,
					series.color), 0, false, series.xaxis, series.yaxis, symbol);
			ctx.restore()
		}
		function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx,
				axisy, c, horizontal, lineWidth) {
			var left, right, bottom, top, drawLeft, drawRight, drawTop, drawBottom, tmp;
			if (horizontal) {
				drawBottom = drawRight = drawTop = true;
				drawLeft = false;
				left = b;
				right = x;
				top = y + barLeft;
				bottom = y + barRight;
				if (right < left) {
					tmp = right;
					right = left;
					left = tmp;
					drawLeft = true;
					drawRight = false
				}
			} else {
				drawLeft = drawRight = drawTop = true;
				drawBottom = false;
				left = x + barLeft;
				right = x + barRight;
				bottom = b;
				top = y;
				if (top < bottom) {
					tmp = top;
					top = bottom;
					bottom = tmp;
					drawBottom = true;
					drawTop = false
				}
			}
			if (right < axisx.min || left > axisx.max || top < axisy.min
					|| bottom > axisy.max) {
				return
			}
			if (left < axisx.min) {
				left = axisx.min;
				drawLeft = false
			}
			if (right > axisx.max) {
				right = axisx.max;
				drawRight = false
			}
			if (bottom < axisy.min) {
				bottom = axisy.min;
				drawBottom = false
			}
			if (top > axisy.max) {
				top = axisy.max;
				drawTop = false
			}
			left = axisx.p2c(left);
			bottom = axisy.p2c(bottom);
			right = axisx.p2c(right);
			top = axisy.p2c(top);
			if (fillStyleCallback) {
				c.fillStyle = fillStyleCallback(bottom, top);
				c.fillRect(left, top, right - left, bottom - top)
			}
			if (lineWidth > 0
					&& (drawLeft || drawRight || drawTop || drawBottom)) {
				c.beginPath();
				c.moveTo(left, bottom);
				if (drawLeft) {
					c.lineTo(left, top)
				} else {
					c.moveTo(left, top)
				}
				if (drawTop) {
					c.lineTo(right, top)
				} else {
					c.moveTo(right, top)
				}
				if (drawRight) {
					c.lineTo(right, bottom)
				} else {
					c.moveTo(right, bottom)
				}
				if (drawBottom) {
					c.lineTo(left, bottom)
				} else {
					c.moveTo(left, bottom)
				}
				c.stroke()
			}
		}
		function drawSeriesBars(series) {
			function plotBars(datapoints, barLeft, barRight, fillStyleCallback,
					axisx, axisy) {
				var points = datapoints.points, ps = datapoints.pointsize;
				for (var i = 0; i < points.length; i += ps) {
					if (points[i] == null) {
						continue
					}
					drawBar(points[i], points[i + 1], points[i + 2], barLeft,
							barRight, fillStyleCallback, axisx, axisy, ctx,
							series.bars.horizontal, series.bars.lineWidth)
				}
			}
			ctx.save();
			ctx.translate(plotOffset.left, plotOffset.top);
			ctx.lineWidth = series.bars.lineWidth;
			ctx.strokeStyle = series.color;
			var barLeft;
			switch (series.bars.align) {
			case "left":
				barLeft = 0;
				break;
			case "right":
				barLeft = -series.bars.barWidth;
				break;
			default:
				barLeft = -series.bars.barWidth / 2
			}
			var fillStyleCallback = series.bars.fill ? function(bottom, top) {
				return getFillStyle(series.bars, series.color, bottom, top)
			} : null;
			plotBars(series.datapoints, barLeft,
					barLeft + series.bars.barWidth, fillStyleCallback,
					series.xaxis, series.yaxis);
			ctx.restore()
		}
		function getFillStyle(filloptions, seriesColor, bottom, top) {
			var fill = filloptions.fill;
			if (!fill) {
				return null
			}
			if (filloptions.fillColor) {
				return getColorOrGradient(filloptions.fillColor, bottom, top,
						seriesColor)
			}
			var c = $.color.parse(seriesColor);
			c.a = typeof fill == "number" ? fill : 0.4;
			c.normalize();
			return c.toString()
		}
		function insertLegend() {
			if (options.legend.container != null) {
				$(options.legend.container).html("")
			} else {
				placeholder.find(".legend").remove()
			}
			if (!options.legend.show) {
				return
			}
			var fragments = [], entries = [], rowStarted = false, lf = options.legend.labelFormatter, s, label;
			for (var i = 0; i < series.length; ++i) {
				s = series[i];
				if (s.label) {
					label = lf ? lf(s.label, s) : s.label;
					if (label) {
						entries.push({
							label : label,
							color : s.color
						})
					}
				}
			}
			if (options.legend.sorted) {
				if ($.isFunction(options.legend.sorted)) {
					entries.sort(options.legend.sorted)
				} else {
					if (options.legend.sorted == "reverse") {
						entries.reverse()
					} else {
						var ascending = options.legend.sorted != "descending";
						entries.sort(function(a, b) {
							return a.label == b.label ? 0
									: ((a.label < b.label) != ascending ? 1
											: -1)
						})
					}
				}
			}
			for (var i = 0; i < entries.length; ++i) {
				var entry = entries[i];
				if (i % options.legend.noColumns == 0) {
					if (rowStarted) {
						fragments.push("</tr>")
					}
					fragments.push("<tr>");
					rowStarted = true
				}
				fragments
						.push('<td class="legendColorBox"><div style="border:1px solid '
								+ options.legend.labelBoxBorderColor
								+ ';padding:1px"><div style="width:4px;height:0;border:5px solid '
								+ entry.color
								+ ';overflow:hidden"></div></div></td><td class="legendLabel">'
								+ entry.label + "</td>")
			}
			if (rowStarted) {
				fragments.push("</tr>")
			}
			if (fragments.length == 0) {
				return
			}
			var table = '<table style="font-size:smaller;color:'
					+ options.grid.color + '">' + fragments.join("")
					+ "</table>";
			if (options.legend.container != null) {
				$(options.legend.container).html(table)
			} else {
				var pos = "", p = options.legend.position, m = options.legend.margin;
				if (m[0] == null) {
					m = [ m, m ]
				}
				if (p.charAt(0) == "n") {
					pos += "top:" + (m[1] + plotOffset.top) + "px;"
				} else {
					if (p.charAt(0) == "s") {
						pos += "bottom:" + (m[1] + plotOffset.bottom) + "px;"
					}
				}
				if (p.charAt(1) == "e") {
					pos += "right:" + (m[0] + plotOffset.right) + "px;"
				} else {
					if (p.charAt(1) == "w") {
						pos += "left:" + (m[0] + plotOffset.left) + "px;"
					}
				}
				var legend = $(
						'<div class="legend">'
								+ table
										.replace('style="',
												'style="position:absolute;'
														+ pos + ";") + "</div>")
						.appendTo(placeholder);
				if (options.legend.backgroundOpacity != 0) {
					var c = options.legend.backgroundColor;
					if (c == null) {
						c = options.grid.backgroundColor;
						if (c && typeof c == "string") {
							c = $.color.parse(c)
						} else {
							c = $.color.extract(legend, "background-color")
						}
						c.a = 1;
						c = c.toString()
					}
					var div = legend.children();
					$(
							'<div style="position:absolute;width:'
									+ div.width() + "px;height:" + div.height()
									+ "px;" + pos + "background-color:" + c
									+ ';"> </div>').prependTo(legend).css(
							"opacity", options.legend.backgroundOpacity)
				}
			}
		}
		var highlights = [], redrawTimeout = null;
		function findNearbyItem(mouseX, mouseY, seriesFilter) {
			var maxDistance = options.grid.mouseActiveRadius, smallestDistance = maxDistance
					* maxDistance + 1, item = null, foundPoint = false, i, j, ps;
			for (i = series.length - 1; i >= 0; --i) {
				if (!seriesFilter(series[i])) {
					continue
				}
				var s = series[i], axisx = s.xaxis, axisy = s.yaxis, points = s.datapoints.points, mx = axisx
						.c2p(mouseX), my = axisy.c2p(mouseY), maxx = maxDistance
						/ axisx.scale, maxy = maxDistance / axisy.scale;
				ps = s.datapoints.pointsize;
				if (axisx.options.inverseTransform) {
					maxx = Number.MAX_VALUE
				}
				if (axisy.options.inverseTransform) {
					maxy = Number.MAX_VALUE
				}
				if (s.lines.show || s.points.show) {
					for (j = 0; j < points.length; j += ps) {
						var x = points[j], y = points[j + 1];
						if (x == null) {
							continue
						}
						if (x - mx > maxx || x - mx < -maxx || y - my > maxy
								|| y - my < -maxy) {
							continue
						}
						var dx = Math.abs(axisx.p2c(x) - mouseX), dy = Math
								.abs(axisy.p2c(y) - mouseY), dist = dx * dx
								+ dy * dy;
						if (dist < smallestDistance) {
							smallestDistance = dist;
							item = [ i, j / ps ]
						}
					}
				}
				if (s.bars.show && !item) {
					var barLeft, barRight;
					switch (s.bars.align) {
					case "left":
						barLeft = 0;
						break;
					case "right":
						barLeft = -s.bars.barWidth;
						break;
					default:
						barLeft = -s.bars.barWidth / 2
					}
					barRight = barLeft + s.bars.barWidth;
					for (j = 0; j < points.length; j += ps) {
						var x = points[j], y = points[j + 1], b = points[j + 2];
						if (x == null) {
							continue
						}
						if (series[i].bars.horizontal ? (mx <= Math.max(b, x)
								&& mx >= Math.min(b, x) && my >= y + barLeft && my <= y
								+ barRight)
								: (mx >= x + barLeft && mx <= x + barRight
										&& my >= Math.min(b, y) && my <= Math
										.max(b, y))) {
							item = [ i, j / ps ]
						}
					}
				}
			}
			if (item) {
				i = item[0];
				j = item[1];
				ps = series[i].datapoints.pointsize;
				return {
					datapoint : series[i].datapoints.points.slice(j * ps,
							(j + 1) * ps),
					dataIndex : j,
					series : series[i],
					seriesIndex : i
				}
			}
			return null
		}
		function onMouseMove(e) {
			if (options.grid.hoverable) {
				triggerClickHoverEvent("plothover", e, function(s) {
					return s.hoverable != false
				})
			}
		}
		function onMouseLeave(e) {
			if (options.grid.hoverable) {
				triggerClickHoverEvent("plothover", e, function(s) {
					return false
				})
			}
		}
		function onClick(e) {
			triggerClickHoverEvent("plotclick", e, function(s) {
				return s.clickable != false
			})
		}
		function triggerClickHoverEvent(eventname, event, seriesFilter) {
			var offset = eventHolder.offset(), canvasX = event.pageX
					- offset.left - plotOffset.left, canvasY = event.pageY
					- offset.top - plotOffset.top, pos = canvasToAxisCoords({
				left : canvasX,
				top : canvasY
			});
			pos.pageX = event.pageX;
			pos.pageY = event.pageY;
			var item = findNearbyItem(canvasX, canvasY, seriesFilter);
			if (item) {
				item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0])
						+ offset.left + plotOffset.left, 10);
				item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1])
						+ offset.top + plotOffset.top, 10)
			}
			if (options.grid.autoHighlight) {
				for (var i = 0; i < highlights.length; ++i) {
					var h = highlights[i];
					if (h.auto == eventname
							&& !(item && h.series == item.series
									&& h.point[0] == item.datapoint[0] && h.point[1] == item.datapoint[1])) {
						unhighlight(h.series, h.point)
					}
				}
				if (item) {
					highlight(item.series, item.datapoint, eventname)
				}
			}
			placeholder.trigger(eventname, [ pos, item ])
		}
		function triggerRedrawOverlay() {
			var t = options.interaction.redrawOverlayInterval;
			if (t == -1) {
				drawOverlay();
				return
			}
			if (!redrawTimeout) {
				redrawTimeout = setTimeout(drawOverlay, t)
			}
		}
		function drawOverlay() {
			redrawTimeout = null;
			octx.save();
			overlay.clear();
			octx.translate(plotOffset.left, plotOffset.top);
			var i, hi;
			for (i = 0; i < highlights.length; ++i) {
				hi = highlights[i];
				if (hi.series.bars.show) {
					drawBarHighlight(hi.series, hi.point)
				} else {
					drawPointHighlight(hi.series, hi.point)
				}
			}
			octx.restore();
			executeHooks(hooks.drawOverlay, [ octx ])
		}
		function highlight(s, point, auto) {
			if (typeof s == "number") {
				s = series[s]
			}
			if (typeof point == "number") {
				var ps = s.datapoints.pointsize;
				point = s.datapoints.points.slice(ps * point, ps * (point + 1))
			}
			var i = indexOfHighlight(s, point);
			if (i == -1) {
				highlights.push({
					series : s,
					point : point,
					auto : auto
				});
				triggerRedrawOverlay()
			} else {
				if (!auto) {
					highlights[i].auto = false
				}
			}
		}
		function unhighlight(s, point) {
			if (s == null && point == null) {
				highlights = [];
				triggerRedrawOverlay();
				return
			}
			if (typeof s == "number") {
				s = series[s]
			}
			if (typeof point == "number") {
				var ps = s.datapoints.pointsize;
				point = s.datapoints.points.slice(ps * point, ps * (point + 1))
			}
			var i = indexOfHighlight(s, point);
			if (i != -1) {
				highlights.splice(i, 1);
				triggerRedrawOverlay()
			}
		}
		function indexOfHighlight(s, p) {
			for (var i = 0; i < highlights.length; ++i) {
				var h = highlights[i];
				if (h.series == s && h.point[0] == p[0] && h.point[1] == p[1]) {
					return i
				}
			}
			return -1
		}
		function drawPointHighlight(series, point) {
			var x = point[0], y = point[1], axisx = series.xaxis, axisy = series.yaxis, highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor
					: $.color.parse(series.color).scale("a", 0.5).toString();
			if (x < axisx.min || x > axisx.max || y < axisy.min
					|| y > axisy.max) {
				return
			}
			var pointRadius = series.points.radius + series.points.lineWidth
					/ 2;
			octx.lineWidth = pointRadius;
			octx.strokeStyle = highlightColor;
			var radius = 1.5 * pointRadius;
			x = axisx.p2c(x);
			y = axisy.p2c(y);
			octx.beginPath();
			if (series.points.symbol == "circle") {
				octx.arc(x, y, radius, 0, 2 * Math.PI, false)
			} else {
				series.points.symbol(octx, x, y, radius, false)
			}
			octx.closePath();
			octx.stroke()
		}
		function drawBarHighlight(series, point) {
			var highlightColor = (typeof series.highlightColor === "string") ? series.highlightColor
					: $.color.parse(series.color).scale("a", 0.5).toString(), fillStyle = highlightColor, barLeft;
			switch (series.bars.align) {
			case "left":
				barLeft = 0;
				break;
			case "right":
				barLeft = -series.bars.barWidth;
				break;
			default:
				barLeft = -series.bars.barWidth / 2
			}
			octx.lineWidth = series.bars.lineWidth;
			octx.strokeStyle = highlightColor;
			drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft
					+ series.bars.barWidth, function() {
				return fillStyle
			}, series.xaxis, series.yaxis, octx, series.bars.horizontal,
					series.bars.lineWidth)
		}
		function getColorOrGradient(spec, bottom, top, defaultColor) {
			if (typeof spec == "string") {
				return spec
			} else {
				var gradient = ctx.createLinearGradient(0, top, 0, bottom);
				for (var i = 0, l = spec.colors.length; i < l; ++i) {
					var c = spec.colors[i];
					if (typeof c != "string") {
						var co = $.color.parse(defaultColor);
						if (c.brightness != null) {
							co = co.scale("rgb", c.brightness)
						}
						if (c.opacity != null) {
							co.a *= c.opacity
						}
						c = co.toString()
					}
					gradient.addColorStop(i / (l - 1), c)
				}
				return gradient
			}
		}
	}
	$.plot = function(placeholder, data, options) {
		var plot = new Plot($(placeholder), data, options, $.plot.plugins);
		return plot
	};
	$.plot.version = "0.8.2";
	$.plot.plugins = [];
	$.fn.plot = function(data, options) {
		return this.each(function() {
			$.plot(this, data, options)
		})
	};
	function floorInBase(n, base) {
		return base * Math.floor(n / base)
	}
})(jQuery);
(function($) {
	var options = {
		xaxis : {
			timezone : null,
			timeformat : null,
			twelveHourClock : false,
			monthNames : null
		}
	};
	function floorInBase(n, base) {
		return base * Math.floor(n / base)
	}
	function formatDate(d, fmt, monthNames, dayNames) {
		if (typeof d.strftime == "function") {
			return d.strftime(fmt)
		}
		var leftPad = function(n, pad) {
			n = "" + n;
			pad = "" + (pad == null ? "0" : pad);
			return n.length == 1 ? pad + n : n
		};
		var r = [];
		var escape = false;
		var hours = d.getHours();
		var isAM = hours < 12;
		if (monthNames == null) {
			monthNames = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
					"Aug", "Sep", "Oct", "Nov", "Dec" ]
		}
		if (dayNames == null) {
			dayNames = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ]
		}
		var hours12;
		if (hours > 12) {
			hours12 = hours - 12
		} else {
			if (hours == 0) {
				hours12 = 12
			} else {
				hours12 = hours
			}
		}
		for (var i = 0; i < fmt.length; ++i) {
			var c = fmt.charAt(i);
			if (escape) {
				switch (c) {
				case "a":
					c = "" + dayNames[d.getDay()];
					break;
				case "b":
					c = "" + monthNames[d.getMonth()];
					break;
				case "d":
					c = leftPad(d.getDate());
					break;
				case "e":
					c = leftPad(d.getDate(), " ");
					break;
				case "h":
				case "H":
					c = leftPad(hours);
					break;
				case "I":
					c = leftPad(hours12);
					break;
				case "l":
					c = leftPad(hours12, " ");
					break;
				case "m":
					c = leftPad(d.getMonth() + 1);
					break;
				case "M":
					c = leftPad(d.getMinutes());
					break;
				case "q":
					c = "" + (Math.floor(d.getMonth() / 3) + 1);
					break;
				case "S":
					c = leftPad(d.getSeconds());
					break;
				case "y":
					c = leftPad(d.getFullYear() % 100);
					break;
				case "Y":
					c = "" + d.getFullYear();
					break;
				case "p":
					c = (isAM) ? ("am") : ("pm");
					break;
				case "P":
					c = (isAM) ? ("AM") : ("PM");
					break;
				case "w":
					c = "" + d.getDay();
					break
				}
				r.push(c);
				escape = false
			} else {
				if (c == "%") {
					escape = true
				} else {
					r.push(c)
				}
			}
		}
		return r.join("")
	}
	function makeUtcWrapper(d) {
		function addProxyMethod(sourceObj, sourceMethod, targetObj,
				targetMethod) {
			sourceObj[sourceMethod] = function() {
				return targetObj[targetMethod].apply(targetObj, arguments)
			}
		}
		var utc = {
			date : d
		};
		if (d.strftime != undefined) {
			addProxyMethod(utc, "strftime", d, "strftime")
		}
		addProxyMethod(utc, "getTime", d, "getTime");
		addProxyMethod(utc, "setTime", d, "setTime");
		var props = [ "Date", "Day", "FullYear", "Hours", "Milliseconds",
				"Minutes", "Month", "Seconds" ];
		for (var p = 0; p < props.length; p++) {
			addProxyMethod(utc, "get" + props[p], d, "getUTC" + props[p]);
			addProxyMethod(utc, "set" + props[p], d, "setUTC" + props[p])
		}
		return utc
	}
	function dateGenerator(ts, opts) {
		if (opts.timezone == "browser") {
			return new Date(ts)
		} else {
			if (!opts.timezone || opts.timezone == "utc") {
				return makeUtcWrapper(new Date(ts))
			} else {
				if (typeof timezoneJS != "undefined"
						&& typeof timezoneJS.Date != "undefined") {
					var d = new timezoneJS.Date();
					d.setTimezone(opts.timezone);
					d.setTime(ts);
					return d
				} else {
					return makeUtcWrapper(new Date(ts))
				}
			}
		}
	}
	var timeUnitSize = {
		second : 1000,
		minute : 60 * 1000,
		hour : 60 * 60 * 1000,
		day : 24 * 60 * 60 * 1000,
		month : 30 * 24 * 60 * 60 * 1000,
		quarter : 3 * 30 * 24 * 60 * 60 * 1000,
		year : 365.2425 * 24 * 60 * 60 * 1000
	};
	var baseSpec = [ [ 1, "second" ], [ 2, "second" ], [ 5, "second" ],
			[ 10, "second" ], [ 30, "second" ], [ 1, "minute" ],
			[ 2, "minute" ], [ 5, "minute" ], [ 10, "minute" ],
			[ 30, "minute" ], [ 1, "hour" ], [ 2, "hour" ], [ 4, "hour" ],
			[ 8, "hour" ], [ 12, "hour" ], [ 1, "day" ], [ 2, "day" ],
			[ 3, "day" ], [ 0.25, "month" ], [ 0.5, "month" ], [ 1, "month" ],
			[ 2, "month" ] ];
	var specMonths = baseSpec.concat([ [ 3, "month" ], [ 6, "month" ],
			[ 1, "year" ] ]);
	var specQuarters = baseSpec.concat([ [ 1, "quarter" ], [ 2, "quarter" ],
			[ 1, "year" ] ]);
	function init(plot) {
		plot.hooks.processOptions
				.push(function(plot, options) {
					$
							.each(
									plot.getAxes(),
									function(axisName, axis) {
										var opts = axis.options;
										if (opts.mode == "time") {
											axis.tickGenerator = function(axis) {
												var ticks = [];
												var d = dateGenerator(axis.min,
														opts);
												var minSize = 0;
												var spec = (opts.tickSize && opts.tickSize[1] === "quarter")
														|| (opts.minTickSize && opts.minTickSize[1] === "quarter") ? specQuarters
														: specMonths;
												if (opts.minTickSize != null) {
													if (typeof opts.tickSize == "number") {
														minSize = opts.tickSize
													} else {
														minSize = opts.minTickSize[0]
																* timeUnitSize[opts.minTickSize[1]]
													}
												}
												for (var i = 0; i < spec.length - 1; ++i) {
													if (axis.delta < (spec[i][0]
															* timeUnitSize[spec[i][1]] + spec[i + 1][0]
															* timeUnitSize[spec[i + 1][1]]) / 2
															&& spec[i][0]
																	* timeUnitSize[spec[i][1]] >= minSize) {
														break
													}
												}
												var size = spec[i][0];
												var unit = spec[i][1];
												if (unit == "year") {
													if (opts.minTickSize != null
															&& opts.minTickSize[1] == "year") {
														size = Math
																.floor(opts.minTickSize[0])
													} else {
														var magn = Math
																.pow(
																		10,
																		Math
																				.floor(Math
																						.log(axis.delta
																								/ timeUnitSize.year)
																						/ Math.LN10));
														var norm = (axis.delta / timeUnitSize.year)
																/ magn;
														if (norm < 1.5) {
															size = 1
														} else {
															if (norm < 3) {
																size = 2
															} else {
																if (norm < 7.5) {
																	size = 5
																} else {
																	size = 10
																}
															}
														}
														size *= magn
													}
													if (size < 1) {
														size = 1
													}
												}
												axis.tickSize = opts.tickSize
														|| [ size, unit ];
												var tickSize = axis.tickSize[0];
												unit = axis.tickSize[1];
												var step = tickSize
														* timeUnitSize[unit];
												if (unit == "second") {
													d.setSeconds(floorInBase(d
															.getSeconds(),
															tickSize))
												} else {
													if (unit == "minute") {
														d
																.setMinutes(floorInBase(
																		d
																				.getMinutes(),
																		tickSize))
													} else {
														if (unit == "hour") {
															d
																	.setHours(floorInBase(
																			d
																					.getHours(),
																			tickSize))
														} else {
															if (unit == "month") {
																d
																		.setMonth(floorInBase(
																				d
																						.getMonth(),
																				tickSize))
															} else {
																if (unit == "quarter") {
																	d
																			.setMonth(3 * floorInBase(
																					d
																							.getMonth() / 3,
																					tickSize))
																} else {
																	if (unit == "year") {
																		d
																				.setFullYear(floorInBase(
																						d
																								.getFullYear(),
																						tickSize))
																	}
																}
															}
														}
													}
												}
												d.setMilliseconds(0);
												if (step >= timeUnitSize.minute) {
													d.setSeconds(0)
												}
												if (step >= timeUnitSize.hour) {
													d.setMinutes(0)
												}
												if (step >= timeUnitSize.day) {
													d.setHours(0)
												}
												if (step >= timeUnitSize.day * 4) {
													d.setDate(1)
												}
												if (step >= timeUnitSize.month * 2) {
													d.setMonth(floorInBase(d
															.getMonth(), 3))
												}
												if (step >= timeUnitSize.quarter * 2) {
													d.setMonth(floorInBase(d
															.getMonth(), 6))
												}
												if (step >= timeUnitSize.year) {
													d.setMonth(0)
												}
												var carry = 0;
												var v = Number.NaN;
												var prev;
												do {
													prev = v;
													v = d.getTime();
													ticks.push(v);
													if (unit == "month"
															|| unit == "quarter") {
														if (tickSize < 1) {
															d.setDate(1);
															var start = d
																	.getTime();
															d
																	.setMonth(d
																			.getMonth()
																			+ (unit == "quarter" ? 3
																					: 1));
															var end = d
																	.getTime();
															d
																	.setTime(v
																			+ carry
																			* timeUnitSize.hour
																			+ (end - start)
																			* tickSize);
															carry = d
																	.getHours();
															d.setHours(0)
														} else {
															d
																	.setMonth(d
																			.getMonth()
																			+ tickSize
																			* (unit == "quarter" ? 3
																					: 1))
														}
													} else {
														if (unit == "year") {
															d
																	.setFullYear(d
																			.getFullYear()
																			+ tickSize)
														} else {
															d.setTime(v + step)
														}
													}
												} while (v < axis.max
														&& v != prev);
												return ticks
											};
											axis.tickFormatter = function(v,
													axis) {
												var d = dateGenerator(v,
														axis.options);
												if (opts.timeformat != null) {
													return formatDate(d,
															opts.timeformat,
															opts.monthNames,
															opts.dayNames)
												}
												var useQuarters = (axis.options.tickSize && axis.options.tickSize[1] == "quarter")
														|| (axis.options.minTickSize && axis.options.minTickSize[1] == "quarter");
												var t = axis.tickSize[0]
														* timeUnitSize[axis.tickSize[1]];
												var span = axis.max - axis.min;
												var suffix = (opts.twelveHourClock) ? " %p"
														: "";
												var hourCode = (opts.twelveHourClock) ? "%I"
														: "%H";
												var fmt;
												if (t < timeUnitSize.minute) {
													fmt = hourCode + ":%M:%S"
															+ suffix
												} else {
													if (t < timeUnitSize.day) {
														if (span < 2 * timeUnitSize.day) {
															fmt = hourCode
																	+ ":%M"
																	+ suffix
														} else {
															fmt = "%b %d "
																	+ hourCode
																	+ ":%M"
																	+ suffix
														}
													} else {
														if (t < timeUnitSize.month) {
															fmt = "%b %d"
														} else {
															if ((useQuarters && t < timeUnitSize.quarter)
																	|| (!useQuarters && t < timeUnitSize.year)) {
																if (span < timeUnitSize.year) {
																	fmt = "%b"
																} else {
																	fmt = "%b %Y"
																}
															} else {
																if (useQuarters
																		&& t < timeUnitSize.year) {
																	if (span < timeUnitSize.year) {
																		fmt = "Q%q"
																	} else {
																		fmt = "Q%q %Y"
																	}
																} else {
																	fmt = "%Y"
																}
															}
														}
													}
												}
												var rt = formatDate(d, fmt,
														opts.monthNames,
														opts.dayNames);
												return rt
											}
										}
									})
				})
	}
	$.plot.plugins.push({
		init : init,
		options : options,
		name : "time",
		version : "1.0"
	});
	$.plot.formatDate = formatDate
})(jQuery);
jQuery.cookie = function(key, value, options) {
	if (arguments.length > 1 && String(value) !== "[object Object]") {
		options = jQuery.extend({}, options);
		if (value === null || value === undefined) {
			options.expires = -1
		}
		if (typeof options.expires === "number") {
			var days = options.expires, t = options.expires = new Date();
			t.setDate(t.getDate() + days)
		}
		value = String(value);
		return (document.cookie = [
				encodeURIComponent(key),
				"=",
				options.raw ? value : encodeURIComponent(value),
				options.expires ? "; expires=" + options.expires.toUTCString()
						: "", options.path ? "; path=" + options.path : "",
				options.domain ? "; domain=" + options.domain : "",
				options.secure ? "; secure" : "" ].join(""))
	}
	options = value || {};
	var result, decode = options.raw ? function(s) {
		return s
	} : decodeURIComponent;
	return (result = new RegExp("(?:^|; )" + encodeURIComponent(key)
			+ "=([^;]*)").exec(document.cookie)) ? decode(result[1]) : null
};
(function($, window) {
	var $window = $(window);
	$.fn.lazyload = function(options) {
		var elements = this;
		var $container;
		var settings = {
			threshold : 0,
			failure_limit : 0,
			event : "scroll",
			effect : "show",
			container : window,
			data_attribute : "original",
			skip_invisible : true,
			appear : null,
			load : null,
			error_url : null
		};
		function update() {
			var counter = 0;
			elements.each(function() {
				var $this = $(this);
				if (settings.skip_invisible && !$this.is(":visible")) {
					return
				}
				if ($.abovethetop(this, settings)
						|| $.leftofbegin(this, settings)) {
				} else {
					if (!$.belowthefold(this, settings)
							&& !$.rightoffold(this, settings)) {
						$this.trigger("appear")
					} else {
						if (++counter > settings.failure_limit) {
							return false
						}
					}
				}
			})
		}
		if (options) {
			if (undefined !== options.failurelimit) {
				options.failure_limit = options.failurelimit;
				delete options.failurelimit
			}
			if (undefined !== options.effectspeed) {
				options.effect_speed = options.effectspeed;
				delete options.effectspeed
			}
			$.extend(settings, options)
		}
		$container = (settings.container === undefined || settings.container === window) ? $window
				: $(settings.container);
		if (0 === settings.event.indexOf("scroll")) {
			$container.bind(settings.event, function(event) {
				return update()
			})
		}
		this
				.each(function() {
					var self = this;
					var $self = $(self);
					self.loaded = false;
					$self
							.one(
									"appear",
									function() {
										if (!this.loaded) {
											if (settings.appear) {
												var elements_left = elements.length;
												settings.appear
														.call(self,
																elements_left,
																settings)
											}
											$("<img />")
													.bind(
															"load",
															function() {
																$self
																		.hide()
																		.attr(
																				"src",
																				$self
																						.data(settings.data_attribute))[settings.effect]
																		(settings.effect_speed);
																self.loaded = true;
																var temp = $
																		.grep(
																				elements,
																				function(
																						element) {
																					return !element.loaded
																				});
																elements = $(temp);
																if (settings.load) {
																	var elements_left = elements.length;
																	settings.load
																			.call(
																					self,
																					elements_left,
																					settings)
																}
															})
													.bind(
															"error",
															function() {
																var size = $self
																		.attr("width");
																$self
																		.hide()
																		.attr(
																				"src",
																				__
																						.getErrorImage(
																								size,
																								settings.error_url))[settings.effect]
																		(settings.effect_speed);
																self.loaded = true;
																var temp = $
																		.grep(
																				elements,
																				function(
																						element) {
																					return !element.loaded
																				});
																elements = $(temp);
																if (settings.load) {
																	var elements_left = elements.length;
																	settings.load
																			.call(
																					self,
																					elements_left,
																					settings)
																}
															})
													.attr(
															"src",
															$self
																	.data(settings.data_attribute))
										}
									});
					if (0 !== settings.event.indexOf("scroll")) {
						$self.bind(settings.event, function(event) {
							if (!self.loaded) {
								$self.trigger("appear")
							}
						})
					}
				});
		$window.bind("resize", function(event) {
			update()
		});
		update();
		return this
	};
	$.belowthefold = function(element, settings) {
		var fold;
		if (settings.container === undefined || settings.container === window) {
			fold = $window.height() + $window.scrollTop()
		} else {
			fold = $(settings.container).offset().top
					+ $(settings.container).height()
		}
		return fold <= $(element).offset().top - settings.threshold
	};
	$.rightoffold = function(element, settings) {
		var fold;
		if (settings.container === undefined || settings.container === window) {
			fold = $window.width() + $window.scrollLeft()
		} else {
			fold = $(settings.container).offset().left
					+ $(settings.container).width()
		}
		return fold <= $(element).offset().left - settings.threshold
	};
	$.abovethetop = function(element, settings) {
		var fold;
		if (settings.container === undefined || settings.container === window) {
			fold = $window.scrollTop()
		} else {
			fold = $(settings.container).offset().top
		}
		return fold >= $(element).offset().top + settings.threshold
				+ $(element).height()
	};
	$.leftofbegin = function(element, settings) {
		var fold;
		if (settings.container === undefined || settings.container === window) {
			fold = $window.scrollLeft()
		} else {
			fold = $(settings.container).offset().left
		}
		return fold >= $(element).offset().left + settings.threshold
				+ $(element).width()
	};
	$.inviewport = function(element, settings) {
		return !$.rightofscreen(element, settings)
				&& !$.leftofscreen(element, settings)
				&& !$.belowthefold(element, settings)
				&& !$.abovethetop(element, settings)
	};
	$.extend($.expr[":"], {
		"below-the-fold" : function(a) {
			return $.belowthefold(a, {
				threshold : 0
			})
		},
		"above-the-top" : function(a) {
			return !$.belowthefold(a, {
				threshold : 0
			})
		},
		"right-of-screen" : function(a) {
			return $.rightoffold(a, {
				threshold : 0
			})
		},
		"left-of-screen" : function(a) {
			return !$.rightoffold(a, {
				threshold : 0
			})
		},
		"in-viewport" : function(a) {
			return !$.inviewport(a, {
				threshold : 0
			})
		},
		"above-the-fold" : function(a) {
			return !$.belowthefold(a, {
				threshold : 0
			})
		},
		"right-of-fold" : function(a) {
			return $.rightoffold(a, {
				threshold : 0
			})
		},
		"left-of-fold" : function(a) {
			return !$.rightoffold(a, {
				threshold : 0
			})
		}
	})
})(jQuery, window);
(function() {
	var root = this;
	var previousUnderscore = root._;
	var breaker = {};
	var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
	var push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
	var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind;
	var _ = function(obj) {
		if (obj instanceof _) {
			return obj
		}
		if (!(this instanceof _)) {
			return new _(obj)
		}
		this._wrapped = obj
	};
	if (typeof exports !== "undefined") {
		if (typeof module !== "undefined" && module.exports) {
			exports = module.exports = _
		}
		exports._ = _
	} else {
		root._ = _
	}
	_.VERSION = "1.6.0";
	var each = _.each = _.forEach = function(obj, iterator, context) {
		if (obj == null) {
			return obj
		}
		if (nativeForEach && obj.forEach === nativeForEach) {
			obj.forEach(iterator, context)
		} else {
			if (obj.length === +obj.length) {
				for (var i = 0, length = obj.length; i < length; i++) {
					if (iterator.call(context, obj[i], i, obj) === breaker) {
						return
					}
				}
			} else {
				var keys = _.keys(obj);
				for (var i = 0, length = keys.length; i < length; i++) {
					if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) {
						return
					}
				}
			}
		}
		return obj
	};
	_.map = _.collect = function(obj, iterator, context) {
		var results = [];
		if (obj == null) {
			return results
		}
		if (nativeMap && obj.map === nativeMap) {
			return obj.map(iterator, context)
		}
		each(obj, function(value, index, list) {
			results.push(iterator.call(context, value, index, list))
		});
		return results
	};
	var reduceError = "Reduce of empty array with no initial value";
	_.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
		var initial = arguments.length > 2;
		if (obj == null) {
			obj = []
		}
		if (nativeReduce && obj.reduce === nativeReduce) {
			if (context) {
				iterator = _.bind(iterator, context)
			}
			return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator)
		}
		each(obj, function(value, index, list) {
			if (!initial) {
				memo = value;
				initial = true
			} else {
				memo = iterator.call(context, memo, value, index, list)
			}
		});
		if (!initial) {
			throw new TypeError(reduceError)
		}
		return memo
	};
	_.reduceRight = _.foldr = function(obj, iterator, memo, context) {
		var initial = arguments.length > 2;
		if (obj == null) {
			obj = []
		}
		if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
			if (context) {
				iterator = _.bind(iterator, context)
			}
			return initial ? obj.reduceRight(iterator, memo) : obj
					.reduceRight(iterator)
		}
		var length = obj.length;
		if (length !== +length) {
			var keys = _.keys(obj);
			length = keys.length
		}
		each(obj, function(value, index, list) {
			index = keys ? keys[--length] : --length;
			if (!initial) {
				memo = obj[index];
				initial = true
			} else {
				memo = iterator.call(context, memo, obj[index], index, list)
			}
		});
		if (!initial) {
			throw new TypeError(reduceError)
		}
		return memo
	};
	_.find = _.detect = function(obj, predicate, context) {
		var result;
		any(obj, function(value, index, list) {
			if (predicate.call(context, value, index, list)) {
				result = value;
				return true
			}
		});
		return result
	};
	_.filter = _.select = function(obj, predicate, context) {
		var results = [];
		if (obj == null) {
			return results
		}
		if (nativeFilter && obj.filter === nativeFilter) {
			return obj.filter(predicate, context)
		}
		each(obj, function(value, index, list) {
			if (predicate.call(context, value, index, list)) {
				results.push(value)
			}
		});
		return results
	};
	_.reject = function(obj, predicate, context) {
		return _.filter(obj, function(value, index, list) {
			return !predicate.call(context, value, index, list)
		}, context)
	};
	_.every = _.all = function(obj, predicate, context) {
		predicate || (predicate = _.identity);
		var result = true;
		if (obj == null) {
			return result
		}
		if (nativeEvery && obj.every === nativeEvery) {
			return obj.every(predicate, context)
		}
		each(obj, function(value, index, list) {
			if (!(result = result
					&& predicate.call(context, value, index, list))) {
				return breaker
			}
		});
		return !!result
	};
	var any = _.some = _.any = function(obj, predicate, context) {
		predicate || (predicate = _.identity);
		var result = false;
		if (obj == null) {
			return result
		}
		if (nativeSome && obj.some === nativeSome) {
			return obj.some(predicate, context)
		}
		each(obj, function(value, index, list) {
			if (result
					|| (result = predicate.call(context, value, index, list))) {
				return breaker
			}
		});
		return !!result
	};
	_.contains = _.include = function(obj, target) {
		if (obj == null) {
			return false
		}
		if (nativeIndexOf && obj.indexOf === nativeIndexOf) {
			return obj.indexOf(target) != -1
		}
		return any(obj, function(value) {
			return value === target
		})
	};
	_.invoke = function(obj, method) {
		var args = slice.call(arguments, 2);
		var isFunc = _.isFunction(method);
		return _.map(obj, function(value) {
			return (isFunc ? method : value[method]).apply(value, args)
		})
	};
	_.pluck = function(obj, key) {
		return _.map(obj, _.property(key))
	};
	_.where = function(obj, attrs) {
		return _.filter(obj, _.matches(attrs))
	};
	_.findWhere = function(obj, attrs) {
		return _.find(obj, _.matches(attrs))
	};
	_.max = function(obj, iterator, context) {
		if (!iterator && _.isArray(obj) && obj[0] === +obj[0]
				&& obj.length < 65535) {
			return Math.max.apply(Math, obj)
		}
		var result = -Infinity, lastComputed = -Infinity;
		each(obj, function(value, index, list) {
			var computed = iterator ? iterator
					.call(context, value, index, list) : value;
			if (computed > lastComputed) {
				result = value;
				lastComputed = computed
			}
		});
		return result
	};
	_.min = function(obj, iterator, context) {
		if (!iterator && _.isArray(obj) && obj[0] === +obj[0]
				&& obj.length < 65535) {
			return Math.min.apply(Math, obj)
		}
		var result = Infinity, lastComputed = Infinity;
		each(obj, function(value, index, list) {
			var computed = iterator ? iterator
					.call(context, value, index, list) : value;
			if (computed < lastComputed) {
				result = value;
				lastComputed = computed
			}
		});
		return result
	};
	_.shuffle = function(obj) {
		var rand;
		var index = 0;
		var shuffled = [];
		each(obj, function(value) {
			rand = _.random(index++);
			shuffled[index - 1] = shuffled[rand];
			shuffled[rand] = value
		});
		return shuffled
	};
	_.sample = function(obj, n, guard) {
		if (n == null || guard) {
			if (obj.length !== +obj.length) {
				obj = _.values(obj)
			}
			return obj[_.random(obj.length - 1)]
		}
		return _.shuffle(obj).slice(0, Math.max(0, n))
	};
	var lookupIterator = function(value) {
		if (value == null) {
			return _.identity
		}
		if (_.isFunction(value)) {
			return value
		}
		return _.property(value)
	};
	_.sortBy = function(obj, iterator, context) {
		iterator = lookupIterator(iterator);
		return _.pluck(_.map(obj, function(value, index, list) {
			return {
				value : value,
				index : index,
				criteria : iterator.call(context, value, index, list)
			}
		}).sort(function(left, right) {
			var a = left.criteria;
			var b = right.criteria;
			if (a !== b) {
				if (a > b || a === void 0) {
					return 1
				}
				if (a < b || b === void 0) {
					return -1
				}
			}
			return left.index - right.index
		}), "value")
	};
	var group = function(behavior) {
		return function(obj, iterator, context) {
			var result = {};
			iterator = lookupIterator(iterator);
			each(obj, function(value, index) {
				var key = iterator.call(context, value, index, obj);
				behavior(result, key, value)
			});
			return result
		}
	};
	_.groupBy = group(function(result, key, value) {
		_.has(result, key) ? result[key].push(value) : result[key] = [ value ]
	});
	_.indexBy = group(function(result, key, value) {
		result[key] = value
	});
	_.countBy = group(function(result, key) {
		_.has(result, key) ? result[key]++ : result[key] = 1
	});
	_.sortedIndex = function(array, obj, iterator, context) {
		iterator = lookupIterator(iterator);
		var value = iterator.call(context, obj);
		var low = 0, high = array.length;
		while (low < high) {
			var mid = (low + high) >>> 1;
			iterator.call(context, array[mid]) < value ? low = mid + 1
					: high = mid
		}
		return low
	};
	_.toArray = function(obj) {
		if (!obj) {
			return []
		}
		if (_.isArray(obj)) {
			return slice.call(obj)
		}
		if (obj.length === +obj.length) {
			return _.map(obj, _.identity)
		}
		return _.values(obj)
	};
	_.size = function(obj) {
		if (obj == null) {
			return 0
		}
		return (obj.length === +obj.length) ? obj.length : _.keys(obj).length
	};
	_.first = _.head = _.take = function(array, n, guard) {
		if (array == null) {
			return void 0
		}
		if ((n == null) || guard) {
			return array[0]
		}
		if (n < 0) {
			return []
		}
		return slice.call(array, 0, n)
	};
	_.initial = function(array, n, guard) {
		return slice.call(array, 0, array.length
				- ((n == null) || guard ? 1 : n))
	};
	_.last = function(array, n, guard) {
		if (array == null) {
			return void 0
		}
		if ((n == null) || guard) {
			return array[array.length - 1]
		}
		return slice.call(array, Math.max(array.length - n, 0))
	};
	_.rest = _.tail = _.drop = function(array, n, guard) {
		return slice.call(array, (n == null) || guard ? 1 : n)
	};
	_.compact = function(array) {
		return _.filter(array, _.identity)
	};
	var flatten = function(input, shallow, output) {
		if (shallow && _.every(input, _.isArray)) {
			return concat.apply(output, input)
		}
		each(input, function(value) {
			if (_.isArray(value) || _.isArguments(value)) {
				shallow ? push.apply(output, value) : flatten(value, shallow,
						output)
			} else {
				output.push(value)
			}
		});
		return output
	};
	_.flatten = function(array, shallow) {
		return flatten(array, shallow, [])
	};
	_.without = function(array) {
		return _.difference(array, slice.call(arguments, 1))
	};
	_.partition = function(array, predicate, context) {
		predicate = lookupIterator(predicate);
		var pass = [], fail = [];
		each(array, function(elem) {
			(predicate.call(context, elem) ? pass : fail).push(elem)
		});
		return [ pass, fail ]
	};
	_.uniq = _.unique = function(array, isSorted, iterator, context) {
		if (_.isFunction(isSorted)) {
			context = iterator;
			iterator = isSorted;
			isSorted = false
		}
		var initial = iterator ? _.map(array, iterator, context) : array;
		var results = [];
		var seen = [];
		each(initial, function(value, index) {
			if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_
					.contains(seen, value)) {
				seen.push(value);
				results.push(array[index])
			}
		});
		return results
	};
	_.union = function() {
		return _.uniq(_.flatten(arguments, true))
	};
	_.intersection = function(array) {
		var rest = slice.call(arguments, 1);
		return _.filter(_.uniq(array), function(item) {
			return _.every(rest, function(other) {
				return _.contains(other, item)
			})
		})
	};
	_.difference = function(array) {
		var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
		return _.filter(array, function(value) {
			return !_.contains(rest, value)
		})
	};
	_.zip = function() {
		var length = _.max(_.pluck(arguments, "length").concat(0));
		var results = new Array(length);
		for (var i = 0; i < length; i++) {
			results[i] = _.pluck(arguments, "" + i)
		}
		return results
	};
	_.object = function(list, values) {
		if (list == null) {
			return {}
		}
		var result = {};
		for (var i = 0, length = list.length; i < length; i++) {
			if (values) {
				result[list[i]] = values[i]
			} else {
				result[list[i][0]] = list[i][1]
			}
		}
		return result
	};
	_.indexOf = function(array, item, isSorted) {
		if (array == null) {
			return -1
		}
		var i = 0, length = array.length;
		if (isSorted) {
			if (typeof isSorted == "number") {
				i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted)
			} else {
				i = _.sortedIndex(array, item);
				return array[i] === item ? i : -1
			}
		}
		if (nativeIndexOf && array.indexOf === nativeIndexOf) {
			return array.indexOf(item, isSorted)
		}
		for (; i < length; i++) {
			if (array[i] === item) {
				return i
			}
		}
		return -1
	};
	_.lastIndexOf = function(array, item, from) {
		if (array == null) {
			return -1
		}
		var hasIndex = from != null;
		if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
			return hasIndex ? array.lastIndexOf(item, from) : array
					.lastIndexOf(item)
		}
		var i = (hasIndex ? from : array.length);
		while (i--) {
			if (array[i] === item) {
				return i
			}
		}
		return -1
	};
	_.range = function(start, stop, step) {
		if (arguments.length <= 1) {
			stop = start || 0;
			start = 0
		}
		step = arguments[2] || 1;
		var length = Math.max(Math.ceil((stop - start) / step), 0);
		var idx = 0;
		var range = new Array(length);
		while (idx < length) {
			range[idx++] = start;
			start += step
		}
		return range
	};
	var ctor = function() {
	};
	_.bind = function(func, context) {
		var args, bound;
		if (nativeBind && func.bind === nativeBind) {
			return nativeBind.apply(func, slice.call(arguments, 1))
		}
		if (!_.isFunction(func)) {
			throw new TypeError
		}
		args = slice.call(arguments, 2);
		return bound = function() {
			if (!(this instanceof bound)) {
				return func.apply(context, args.concat(slice.call(arguments)))
			}
			ctor.prototype = func.prototype;
			var self = new ctor;
			ctor.prototype = null;
			var result = func.apply(self, args.concat(slice.call(arguments)));
			if (Object(result) === result) {
				return result
			}
			return self
		}
	};
	_.partial = function(func) {
		var boundArgs = slice.call(arguments, 1);
		return function() {
			var position = 0;
			var args = boundArgs.slice();
			for (var i = 0, length = args.length; i < length; i++) {
				if (args[i] === _) {
					args[i] = arguments[position++]
				}
			}
			while (position < arguments.length) {
				args.push(arguments[position++])
			}
			return func.apply(this, args)
		}
	};
	_.bindAll = function(obj) {
		var funcs = slice.call(arguments, 1);
		if (funcs.length === 0) {
			throw new Error("bindAll must be passed function names")
		}
		each(funcs, function(f) {
			obj[f] = _.bind(obj[f], obj)
		});
		return obj
	};
	_.memoize = function(func, hasher) {
		var memo = {};
		hasher || (hasher = _.identity);
		return function() {
			var key = hasher.apply(this, arguments);
			return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this,
					arguments))
		}
	};
	_.delay = function(func, wait) {
		var args = slice.call(arguments, 2);
		return setTimeout(function() {
			return func.apply(null, args)
		}, wait)
	};
	_.defer = function(func) {
		return _.delay.apply(_, [ func, 1 ].concat(slice.call(arguments, 1)))
	};
	_.throttle = function(func, wait, options) {
		var context, args, result;
		var timeout = null;
		var previous = 0;
		options || (options = {});
		var later = function() {
			previous = options.leading === false ? 0 : _.now();
			timeout = null;
			result = func.apply(context, args);
			context = args = null
		};
		return function() {
			var now = _.now();
			if (!previous && options.leading === false) {
				previous = now
			}
			var remaining = wait - (now - previous);
			context = this;
			args = arguments;
			if (remaining <= 0) {
				clearTimeout(timeout);
				timeout = null;
				previous = now;
				result = func.apply(context, args);
				context = args = null
			} else {
				if (!timeout && options.trailing !== false) {
					timeout = setTimeout(later, remaining)
				}
			}
			return result
		}
	};
	_.debounce = function(func, wait, immediate) {
		var timeout, args, context, timestamp, result;
		var later = function() {
			var last = _.now() - timestamp;
			if (last < wait) {
				timeout = setTimeout(later, wait - last)
			} else {
				timeout = null;
				if (!immediate) {
					result = func.apply(context, args);
					context = args = null
				}
			}
		};
		return function() {
			context = this;
			args = arguments;
			timestamp = _.now();
			var callNow = immediate && !timeout;
			if (!timeout) {
				timeout = setTimeout(later, wait)
			}
			if (callNow) {
				result = func.apply(context, args);
				context = args = null
			}
			return result
		}
	};
	_.once = function(func) {
		var ran = false, memo;
		return function() {
			if (ran) {
				return memo
			}
			ran = true;
			memo = func.apply(this, arguments);
			func = null;
			return memo
		}
	};
	_.wrap = function(func, wrapper) {
		return _.partial(wrapper, func)
	};
	_.compose = function() {
		var funcs = arguments;
		return function() {
			var args = arguments;
			for (var i = funcs.length - 1; i >= 0; i--) {
				args = [ funcs[i].apply(this, args) ]
			}
			return args[0]
		}
	};
	_.after = function(times, func) {
		return function() {
			if (--times < 1) {
				return func.apply(this, arguments)
			}
		}
	};
	_.keys = function(obj) {
		if (!_.isObject(obj)) {
			return []
		}
		if (nativeKeys) {
			return nativeKeys(obj)
		}
		var keys = [];
		for ( var key in obj) {
			if (_.has(obj, key)) {
				keys.push(key)
			}
		}
		return keys
	};
	_.values = function(obj) {
		var keys = _.keys(obj);
		var length = keys.length;
		var values = new Array(length);
		for (var i = 0; i < length; i++) {
			values[i] = obj[keys[i]]
		}
		return values
	};
	_.pairs = function(obj) {
		var keys = _.keys(obj);
		var length = keys.length;
		var pairs = new Array(length);
		for (var i = 0; i < length; i++) {
			pairs[i] = [ keys[i], obj[keys[i]] ]
		}
		return pairs
	};
	_.invert = function(obj) {
		var result = {};
		var keys = _.keys(obj);
		for (var i = 0, length = keys.length; i < length; i++) {
			result[obj[keys[i]]] = keys[i]
		}
		return result
	};
	_.functions = _.methods = function(obj) {
		var names = [];
		for ( var key in obj) {
			if (_.isFunction(obj[key])) {
				names.push(key)
			}
		}
		return names.sort()
	};
	_.extend = function(obj) {
		each(slice.call(arguments, 1), function(source) {
			if (source) {
				for ( var prop in source) {
					obj[prop] = source[prop]
				}
			}
		});
		return obj
	};
	_.pick = function(obj) {
		var copy = {};
		var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
		each(keys, function(key) {
			if (key in obj) {
				copy[key] = obj[key]
			}
		});
		return copy
	};
	_.omit = function(obj) {
		var copy = {};
		var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
		for ( var key in obj) {
			if (!_.contains(keys, key)) {
				copy[key] = obj[key]
			}
		}
		return copy
	};
	_.defaults = function(obj) {
		each(slice.call(arguments, 1), function(source) {
			if (source) {
				for ( var prop in source) {
					if (obj[prop] === void 0) {
						obj[prop] = source[prop]
					}
				}
			}
		});
		return obj
	};
	_.clone = function(obj) {
		if (!_.isObject(obj)) {
			return obj
		}
		return _.isArray(obj) ? obj.slice() : _.extend({}, obj)
	};
	_.tap = function(obj, interceptor) {
		interceptor(obj);
		return obj
	};
	var eq = function(a, b, aStack, bStack) {
		if (a === b) {
			return a !== 0 || 1 / a == 1 / b
		}
		if (a == null || b == null) {
			return a === b
		}
		if (a instanceof _) {
			a = a._wrapped
		}
		if (b instanceof _) {
			b = b._wrapped
		}
		var className = toString.call(a);
		if (className != toString.call(b)) {
			return false
		}
		switch (className) {
		case "[object String]":
			return a == String(b);
		case "[object Number]":
			return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
		case "[object Date]":
		case "[object Boolean]":
			return +a == +b;
		case "[object RegExp]":
			return a.source == b.source && a.global == b.global
					&& a.multiline == b.multiline
					&& a.ignoreCase == b.ignoreCase
		}
		if (typeof a != "object" || typeof b != "object") {
			return false
		}
		var length = aStack.length;
		while (length--) {
			if (aStack[length] == a) {
				return bStack[length] == b
			}
		}
		var aCtor = a.constructor, bCtor = b.constructor;
		if (aCtor !== bCtor
				&& !(_.isFunction(aCtor) && (aCtor instanceof aCtor)
						&& _.isFunction(bCtor) && (bCtor instanceof bCtor))
				&& ("constructor" in a && "constructor" in b)) {
			return false
		}
		aStack.push(a);
		bStack.push(b);
		var size = 0, result = true;
		if (className == "[object Array]") {
			size = a.length;
			result = size == b.length;
			if (result) {
				while (size--) {
					if (!(result = eq(a[size], b[size], aStack, bStack))) {
						break
					}
				}
			}
		} else {
			for ( var key in a) {
				if (_.has(a, key)) {
					size++;
					if (!(result = _.has(b, key)
							&& eq(a[key], b[key], aStack, bStack))) {
						break
					}
				}
			}
			if (result) {
				for (key in b) {
					if (_.has(b, key) && !(size--)) {
						break
					}
				}
				result = !size
			}
		}
		aStack.pop();
		bStack.pop();
		return result
	};
	_.isEqual = function(a, b) {
		return eq(a, b, [], [])
	};
	_.isEmpty = function(obj) {
		if (obj == null) {
			return true
		}
		if (_.isArray(obj) || _.isString(obj)) {
			return obj.length === 0
		}
		for ( var key in obj) {
			if (_.has(obj, key)) {
				return false
			}
		}
		return true
	};
	_.isElement = function(obj) {
		return !!(obj && obj.nodeType === 1)
	};
	_.isArray = nativeIsArray || function(obj) {
		return toString.call(obj) == "[object Array]"
	};
	_.isObject = function(obj) {
		return obj === Object(obj)
	};
	each([ "Arguments", "Function", "String", "Number", "Date", "RegExp" ],
			function(name) {
				_["is" + name] = function(obj) {
					return toString.call(obj) == "[object " + name + "]"
				}
			});
	if (!_.isArguments(arguments)) {
		_.isArguments = function(obj) {
			return !!(obj && _.has(obj, "callee"))
		}
	}
	if (typeof (/./) !== "function") {
		_.isFunction = function(obj) {
			return typeof obj === "function"
		}
	}
	_.isFinite = function(obj) {
		return isFinite(obj) && !isNaN(parseFloat(obj))
	};
	_.isNaN = function(obj) {
		return _.isNumber(obj) && obj != +obj
	};
	_.isBoolean = function(obj) {
		return obj === true || obj === false
				|| toString.call(obj) == "[object Boolean]"
	};
	_.isNull = function(obj) {
		return obj === null
	};
	_.isUndefined = function(obj) {
		return obj === void 0
	};
	_.has = function(obj, key) {
		return hasOwnProperty.call(obj, key)
	};
	_.noConflict = function() {
		root._ = previousUnderscore;
		return this
	};
	_.identity = function(value) {
		return value
	};
	_.constant = function(value) {
		return function() {
			return value
		}
	};
	_.property = function(key) {
		return function(obj) {
			return obj[key]
		}
	};
	_.matches = function(attrs) {
		return function(obj) {
			if (obj === attrs) {
				return true
			}
			for ( var key in attrs) {
				if (attrs[key] !== obj[key]) {
					return false
				}
			}
			return true
		}
	};
	_.times = function(n, iterator, context) {
		var accum = Array(Math.max(0, n));
		for (var i = 0; i < n; i++) {
			accum[i] = iterator.call(context, i)
		}
		return accum
	};
	_.random = function(min, max) {
		if (max == null) {
			max = min;
			min = 0
		}
		return min + Math.floor(Math.random() * (max - min + 1))
	};
	_.now = Date.now || function() {
		return new Date().getTime()
	};
	var entityMap = {
		escape : {
			"&" : "&amp;",
			"<" : "&lt;",
			">" : "&gt;",
			'"' : "&quot;",
			"'" : "&#x27;"
		}
	};
	entityMap.unescape = _.invert(entityMap.escape);
	var entityRegexes = {
		escape : new RegExp("[" + _.keys(entityMap.escape).join("") + "]", "g"),
		unescape : new RegExp("(" + _.keys(entityMap.unescape).join("|") + ")",
				"g")
	};
	_.each([ "escape", "unescape" ], function(method) {
		_[method] = function(string) {
			if (string == null) {
				return ""
			}
			return ("" + string).replace(entityRegexes[method],
					function(match) {
						return entityMap[method][match]
					})
		}
	});
	_.result = function(object, property) {
		if (object == null) {
			return void 0
		}
		var value = object[property];
		return _.isFunction(value) ? value.call(object) : value
	};
	_.mixin = function(obj) {
		each(_.functions(obj), function(name) {
			var func = _[name] = obj[name];
			_.prototype[name] = function() {
				var args = [ this._wrapped ];
				push.apply(args, arguments);
				return result.call(this, func.apply(_, args))
			}
		})
	};
	var idCounter = 0;
	_.uniqueId = function(prefix) {
		var id = ++idCounter + "";
		return prefix ? prefix + id : id
	};
	_.templateSettings = {
		evaluate : /<%([\s\S]+?)%>/g,
		interpolate : /<%=([\s\S]+?)%>/g,
		escape : /<%-([\s\S]+?)%>/g
	};
	var noMatch = /(.)^/;
	var escapes = {
		"'" : "'",
		"\\" : "\\",
		"\r" : "r",
		"\n" : "n",
		"\t" : "t",
		"\u2028" : "u2028",
		"\u2029" : "u2029"
	};
	var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
	_.template = function(text, data, settings) {
		var render;
		settings = _.defaults({}, settings, _.templateSettings);
		var matcher = new RegExp([ (settings.escape || noMatch).source,
				(settings.interpolate || noMatch).source,
				(settings.evaluate || noMatch).source ].join("|")
				+ "|$", "g");
		var index = 0;
		var source = "__p+='";
		text.replace(matcher, function(match, escape, interpolate, evaluate,
				offset) {
			source += text.slice(index, offset).replace(escaper,
					function(match) {
						return "\\" + escapes[match]
					});
			if (escape) {
				source += "'+\n((__t=(" + escape
						+ "))==null?'':_.escape(__t))+\n'"
			}
			if (interpolate) {
				source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'"
			}
			if (evaluate) {
				source += "';\n" + evaluate + "\n__p+='"
			}
			index = offset + match.length;
			return match
		});
		source += "';\n";
		if (!settings.variable) {
			source = "with(obj||{}){\n" + source + "}\n"
		}
		source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n"
				+ source + "return __p;\n";
		try {
			render = new Function(settings.variable || "obj", "_", source)
		} catch (e) {
			e.source = source;
			throw e
		}
		if (data) {
			return render(data, _)
		}
		var template = function(data) {
			return render.call(this, data, _)
		};
		template.source = "function(" + (settings.variable || "obj") + "){\n"
				+ source + "}";
		return template
	};
	_.chain = function(obj) {
		return _(obj).chain()
	};
	var result = function(obj) {
		return this._chain ? _(obj).chain() : obj
	};
	_.mixin(_);
	each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ],
			function(name) {
				var method = ArrayProto[name];
				_.prototype[name] = function() {
					var obj = this._wrapped;
					method.apply(obj, arguments);
					if ((name == "shift" || name == "splice")
							&& obj.length === 0) {
						delete obj[0]
					}
					return result.call(this, obj)
				}
			});
	each([ "concat", "join", "slice" ], function(name) {
		var method = ArrayProto[name];
		_.prototype[name] = function() {
			return result.call(this, method.apply(this._wrapped, arguments))
		}
	});
	_.extend(_.prototype, {
		chain : function() {
			this._chain = true;
			return this
		},
		value : function() {
			return this._wrapped
		}
	});
	if (typeof define === "function" && define.amd) {
		define("underscore", [], function() {
			return _
		})
	}
}).call(this);
(function(root, factory) {
	if (typeof define === "function" && define.amd) {
		define([ "underscore", "jquery", "exports" ], function(_, $, exports) {
			root.Backbone = factory(root, exports, _, $)
		})
	} else {
		if (typeof exports !== "undefined") {
			var _ = require("underscore");
			factory(root, exports, _)
		} else {
			root.Backbone = factory(root, {}, root._, (root.jQuery
					|| root.Zepto || root.ender || root.$))
		}
	}
}
		(
				this,
				function(root, Backbone, _, $) {
					var previousBackbone = root.Backbone;
					var array = [];
					var push = array.push;
					var slice = array.slice;
					var splice = array.splice;
					Backbone.VERSION = "1.1.2";
					Backbone.$ = $;
					Backbone.noConflict = function() {
						root.Backbone = previousBackbone;
						return this
					};
					Backbone.emulateHTTP = false;
					Backbone.emulateJSON = false;
					var Events = Backbone.Events = {
						on : function(name, callback, context) {
							if (!eventsApi(this, "on", name, [ callback,
									context ])
									|| !callback) {
								return this
							}
							this._events || (this._events = {});
							var events = this._events[name]
									|| (this._events[name] = []);
							events.push({
								callback : callback,
								context : context,
								ctx : context || this
							});
							return this
						},
						once : function(name, callback, context) {
							if (!eventsApi(this, "once", name, [ callback,
									context ])
									|| !callback) {
								return this
							}
							var self = this;
							var once = _.once(function() {
								self.off(name, once);
								callback.apply(this, arguments)
							});
							once._callback = callback;
							return this.on(name, once, context)
						},
						off : function(name, callback, context) {
							var retain, ev, events, names, i, l, j, k;
							if (!this._events
									|| !eventsApi(this, "off", name, [
											callback, context ])) {
								return this
							}
							if (!name && !callback && !context) {
								this._events = void 0;
								return this
							}
							names = name ? [ name ] : _.keys(this._events);
							for (i = 0, l = names.length; i < l; i++) {
								name = names[i];
								if (events = this._events[name]) {
									this._events[name] = retain = [];
									if (callback || context) {
										for (j = 0, k = events.length; j < k; j++) {
											ev = events[j];
											if ((callback
													&& callback !== ev.callback && callback !== ev.callback._callback)
													|| (context && context !== ev.context)) {
												retain.push(ev)
											}
										}
									}
									if (!retain.length) {
										delete this._events[name]
									}
								}
							}
							return this
						},
						trigger : function(name) {
							if (!this._events) {
								return this
							}
							var args = slice.call(arguments, 1);
							if (!eventsApi(this, "trigger", name, args)) {
								return this
							}
							var events = this._events[name];
							var allEvents = this._events.all;
							if (events) {
								triggerEvents(events, args)
							}
							if (allEvents) {
								triggerEvents(allEvents, arguments)
							}
							return this
						},
						stopListening : function(obj, name, callback) {
							var listeningTo = this._listeningTo;
							if (!listeningTo) {
								return this
							}
							var remove = !name && !callback;
							if (!callback && typeof name === "object") {
								callback = this
							}
							if (obj) {
								(listeningTo = {})[obj._listenId] = obj
							}
							for ( var id in listeningTo) {
								obj = listeningTo[id];
								obj.off(name, callback, this);
								if (remove || _.isEmpty(obj._events)) {
									delete this._listeningTo[id]
								}
							}
							return this
						}
					};
					var eventSplitter = /\s+/;
					var eventsApi = function(obj, action, name, rest) {
						if (!name) {
							return true
						}
						if (typeof name === "object") {
							for ( var key in name) {
								obj[action].apply(obj, [ key, name[key] ]
										.concat(rest))
							}
							return false
						}
						if (eventSplitter.test(name)) {
							var names = name.split(eventSplitter);
							for (var i = 0, l = names.length; i < l; i++) {
								obj[action].apply(obj, [ names[i] ]
										.concat(rest))
							}
							return false
						}
						return true
					};
					var triggerEvents = function(events, args) {
						var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
						switch (args.length) {
						case 0:
							while (++i < l) {
								(ev = events[i]).callback.call(ev.ctx)
							}
							return;
						case 1:
							while (++i < l) {
								(ev = events[i]).callback.call(ev.ctx, a1)
							}
							return;
						case 2:
							while (++i < l) {
								(ev = events[i]).callback.call(ev.ctx, a1, a2)
							}
							return;
						case 3:
							while (++i < l) {
								(ev = events[i]).callback.call(ev.ctx, a1, a2,
										a3)
							}
							return;
						default:
							while (++i < l) {
								(ev = events[i]).callback.apply(ev.ctx, args)
							}
							return
						}
					};
					var listenMethods = {
						listenTo : "on",
						listenToOnce : "once"
					};
					_.each(listenMethods, function(implementation, method) {
						Events[method] = function(obj, name, callback) {
							var listeningTo = this._listeningTo
									|| (this._listeningTo = {});
							var id = obj._listenId
									|| (obj._listenId = _.uniqueId("l"));
							listeningTo[id] = obj;
							if (!callback && typeof name === "object") {
								callback = this
							}
							obj[implementation](name, callback, this);
							return this
						}
					});
					Events.bind = Events.on;
					Events.unbind = Events.off;
					_.extend(Backbone, Events);
					var Model = Backbone.Model = function(attributes, options) {
						var attrs = attributes || {};
						options || (options = {});
						this.cid = _.uniqueId("c");
						this.attributes = {};
						if (options.collection) {
							this.collection = options.collection
						}
						if (options.parse) {
							attrs = this.parse(attrs, options) || {}
						}
						attrs = _.defaults({}, attrs, _
								.result(this, "defaults"));
						this.set(attrs, options);
						this.changed = {};
						this.initialize.apply(this, arguments)
					};
					_
							.extend(
									Model.prototype,
									Events,
									{
										changed : null,
										validationError : null,
										idAttribute : "id",
										initialize : function() {
										},
										toJSON : function(options) {
											return _.clone(this.attributes)
										},
										sync : function() {
											return Backbone.sync.apply(this,
													arguments)
										},
										get : function(attr) {
											return this.attributes[attr]
										},
										escape : function(attr) {
											return _.escape(this.get(attr))
										},
										has : function(attr) {
											return this.get(attr) != null
										},
										set : function(key, val, options) {
											var attr, attrs, unset, changes, silent, changing, prev, current;
											if (key == null) {
												return this
											}
											if (typeof key === "object") {
												attrs = key;
												options = val
											} else {
												(attrs = {})[key] = val
											}
											options || (options = {});
											if (!this._validate(attrs, options)) {
												return false
											}
											unset = options.unset;
											silent = options.silent;
											changes = [];
											changing = this._changing;
											this._changing = true;
											if (!changing) {
												this._previousAttributes = _
														.clone(this.attributes);
												this.changed = {}
											}
													current = this.attributes,
													prev = this._previousAttributes;
											if (this.idAttribute in attrs) {
												this.id = attrs[this.idAttribute]
											}
											for (attr in attrs) {
												val = attrs[attr];
												if (!_.isEqual(current[attr],
														val)) {
													changes.push(attr)
												}
												if (!_.isEqual(prev[attr], val)) {
													this.changed[attr] = val
												} else {
													delete this.changed[attr]
												}
												unset ? delete current[attr]
														: current[attr] = val
											}
											if (!silent) {
												if (changes.length) {
													this._pending = options
												}
												for (var i = 0, l = changes.length; i < l; i++) {
													this
															.trigger(
																	"change:"
																			+ changes[i],
																	this,
																	current[changes[i]],
																	options)
												}
											}
											if (changing) {
												return this
											}
											if (!silent) {
												while (this._pending) {
													options = this._pending;
													this._pending = false;
													this.trigger("change",
															this, options)
												}
											}
											this._pending = false;
											this._changing = false;
											return this
										},
										unset : function(attr, options) {
											return this.set(attr, void 0, _
													.extend({}, options, {
														unset : true
													}))
										},
										clear : function(options) {
											var attrs = {};
											for ( var key in this.attributes) {
												attrs[key] = void 0
											}
											return this.set(attrs, _.extend({},
													options, {
														unset : true
													}))
										},
										hasChanged : function(attr) {
											if (attr == null) {
												return !_.isEmpty(this.changed)
											}
											return _.has(this.changed, attr)
										},
										changedAttributes : function(diff) {
											if (!diff) {
												return this.hasChanged() ? _
														.clone(this.changed)
														: false
											}
											var val, changed = false;
											var old = this._changing ? this._previousAttributes
													: this.attributes;
											for ( var attr in diff) {
												if (_.isEqual(old[attr],
														(val = diff[attr]))) {
													continue
												}
												(changed || (changed = {}))[attr] = val
											}
											return changed
										},
										previous : function(attr) {
											if (attr == null
													|| !this._previousAttributes) {
												return null
											}
											return this._previousAttributes[attr]
										},
										previousAttributes : function() {
											return _
													.clone(this._previousAttributes)
										},
										fetch : function(options) {
											options = options ? _
													.clone(options) : {};
											if (options.parse === void 0) {
												options.parse = true
											}
											var model = this;
											var success = options.success;
											options.success = function(resp) {
												if (!model
														.set(model.parse(resp,
																options),
																options)) {
													return false
												}
												if (success) {
													success(model, resp,
															options)
												}
												model.trigger("sync", model,
														resp, options)
											};
											wrapError(this, options);
											return this.sync("read", this,
													options)
										},
										save : function(key, val, options) {
											var attrs, method, xhr, attributes = this.attributes;
											if (key == null
													|| typeof key === "object") {
												attrs = key;
												options = val
											} else {
												(attrs = {})[key] = val
											}
											options = _.extend({
												validate : true
											}, options);
											if (attrs && !options.wait) {
												if (!this.set(attrs, options)) {
													return false
												}
											} else {
												if (!this._validate(attrs,
														options)) {
													return false
												}
											}
											if (attrs && options.wait) {
												this.attributes = _.extend({},
														attributes, attrs)
											}
											if (options.parse === void 0) {
												options.parse = true
											}
											var model = this;
											var success = options.success;
											options.success = function(resp) {
												model.attributes = attributes;
												var serverAttrs = model.parse(
														resp, options);
												if (options.wait) {
													serverAttrs = _.extend(
															attrs || {},
															serverAttrs)
												}
												if (_.isObject(serverAttrs)
														&& !model.set(
																serverAttrs,
																options)) {
													return false
												}
												if (success) {
													success(model, resp,
															options)
												}
												model.trigger("sync", model,
														resp, options)
											};
											wrapError(this, options);
											method = this.isNew() ? "create"
													: (options.patch ? "patch"
															: "update");
											if (method === "patch") {
												options.attrs = attrs
											}
											xhr = this.sync(method, this,
													options);
											if (attrs && options.wait) {
												this.attributes = attributes
											}
											return xhr
										},
										destroy : function(options) {
											options = options ? _
													.clone(options) : {};
											var model = this;
											var success = options.success;
											var destroy = function() {
												model.trigger("destroy", model,
														model.collection,
														options)
											};
											options.success = function(resp) {
												if (options.wait
														|| model.isNew()) {
													destroy()
												}
												if (success) {
													success(model, resp,
															options)
												}
												if (!model.isNew()) {
													model.trigger("sync",
															model, resp,
															options)
												}
											};
											if (this.isNew()) {
												options.success();
												return false
											}
											wrapError(this, options);
											var xhr = this.sync("delete", this,
													options);
											if (!options.wait) {
												destroy()
											}
											return xhr
										},
										url : function() {
											var base = _
													.result(this, "urlRoot")
													|| _.result(
															this.collection,
															"url")
													|| urlError();
											if (this.isNew()) {
												return base
											}
											return base.replace(/([^\/])$/,
													"$1/")
													+ encodeURIComponent(this.id)
										},
										parse : function(resp, options) {
											return resp
										},
										clone : function() {
											return new this.constructor(
													this.attributes)
										},
										isNew : function() {
											return !this.has(this.idAttribute)
										},
										isValid : function(options) {
											return this._validate({}, _.extend(
													options || {}, {
														validate : true
													}))
										},
										_validate : function(attrs, options) {
											if (!options.validate
													|| !this.validate) {
												return true
											}
											attrs = _.extend({},
													this.attributes, attrs);
											var error = this.validationError = this
													.validate(attrs, options)
													|| null;
											if (!error) {
												return true
											}
											this.trigger("invalid", this,
													error, _.extend(options, {
														validationError : error
													}));
											return false
										}
									});
					var modelMethods = [ "keys", "values", "pairs", "invert",
							"pick", "omit" ];
					_.each(modelMethods, function(method) {
						Model.prototype[method] = function() {
							var args = slice.call(arguments);
							args.unshift(this.attributes);
							return _[method].apply(_, args)
						}
					});
					var Collection = Backbone.Collection = function(models,
							options) {
						options || (options = {});
						if (options.model) {
							this.model = options.model
						}
						if (options.comparator !== void 0) {
							this.comparator = options.comparator
						}
						this._reset();
						this.initialize.apply(this, arguments);
						if (models) {
							this.reset(models, _.extend({
								silent : true
							}, options))
						}
					};
					var setOptions = {
						add : true,
						remove : true,
						merge : true
					};
					var addOptions = {
						add : true,
						remove : false
					};
					_
							.extend(
									Collection.prototype,
									Events,
									{
										model : Model,
										initialize : function() {
										},
										toJSON : function(options) {
											return this.map(function(model) {
												return model.toJSON(options)
											})
										},
										sync : function() {
											return Backbone.sync.apply(this,
													arguments)
										},
										add : function(models, options) {
											return this.set(models, _.extend({
												merge : false
											}, options, addOptions))
										},
										remove : function(models, options) {
											var singular = !_.isArray(models);
											models = singular ? [ models ] : _
													.clone(models);
											options || (options = {});
											var i, l, index, model;
											for (i = 0, l = models.length; i < l; i++) {
												model = models[i] = this
														.get(models[i]);
												if (!model) {
													continue
												}
												delete this._byId[model.id];
												delete this._byId[model.cid];
												index = this.indexOf(model);
												this.models.splice(index, 1);
												this.length--;
												if (!options.silent) {
													options.index = index;
													model.trigger("remove",
															model, this,
															options)
												}
												this._removeReference(model,
														options)
											}
											return singular ? models[0]
													: models
										},
										set : function(models, options) {
											options = _.defaults({}, options,
													setOptions);
											if (options.parse) {
												models = this.parse(models,
														options)
											}
											var singular = !_.isArray(models);
											models = singular ? (models ? [ models ]
													: [])
													: _.clone(models);
											var i, l, id, model, attrs, existing, sort;
											var at = options.at;
											var targetModel = this.model;
											var sortable = this.comparator
													&& (at == null)
													&& options.sort !== false;
											var sortAttr = _
													.isString(this.comparator) ? this.comparator
													: null;
											var toAdd = [], toRemove = [], modelMap = {};
											var add = options.add, merge = options.merge, remove = options.remove;
											var order = !sortable && add
													&& remove ? [] : false;
											for (i = 0, l = models.length; i < l; i++) {
												attrs = models[i] || {};
												if (attrs instanceof Model) {
													id = model = attrs
												} else {
													id = attrs[targetModel.prototype.idAttribute
															|| "id"]
												}
												if (existing = this.get(id)) {
													if (remove) {
														modelMap[existing.cid] = true
													}
													if (merge) {
														attrs = attrs === model ? model.attributes
																: attrs;
														if (options.parse) {
															attrs = existing
																	.parse(
																			attrs,
																			options)
														}
														existing.set(attrs,
																options);
														if (sortable
																&& !sort
																&& existing
																		.hasChanged(sortAttr)) {
															sort = true
														}
													}
													models[i] = existing
												} else {
													if (add) {
														model = models[i] = this
																._prepareModel(
																		attrs,
																		options);
														if (!model) {
															continue
														}
														toAdd.push(model);
														this._addReference(
																model, options)
													}
												}
												model = existing || model;
												if (order
														&& (model.isNew() || !modelMap[model.id])) {
													order.push(model)
												}
												modelMap[model.id] = true
											}
											if (remove) {
												for (i = 0, l = this.length; i < l; ++i) {
													if (!modelMap[(model = this.models[i]).cid]) {
														toRemove.push(model)
													}
												}
												if (toRemove.length) {
													this.remove(toRemove,
															options)
												}
											}
											if (toAdd.length
													|| (order && order.length)) {
												if (sortable) {
													sort = true
												}
												this.length += toAdd.length;
												if (at != null) {
													for (i = 0,
															l = toAdd.length; i < l; i++) {
														this.models.splice(at
																+ i, 0,
																toAdd[i])
													}
												} else {
													if (order) {
														this.models.length = 0
													}
													var orderedModels = order
															|| toAdd;
													for (
															i = 0,
															l = orderedModels.length; i < l; i++) {
														this.models
																.push(orderedModels[i])
													}
												}
											}
											if (sort) {
												this.sort({
													silent : true
												})
											}
											if (!options.silent) {
												for (i = 0, l = toAdd.length; i < l; i++) {
													(model = toAdd[i]).trigger(
															"add", model, this,
															options)
												}
												if (sort
														|| (order && order.length)) {
													this.trigger("sort", this,
															options)
												}
											}
											return singular ? models[0]
													: models
										},
										reset : function(models, options) {
											options || (options = {});
											for (var i = 0, l = this.models.length; i < l; i++) {
												this
														._removeReference(
																this.models[i],
																options)
											}
											options.previousModels = this.models;
											this._reset();
											models = this.add(models, _.extend(
													{
														silent : true
													}, options));
											if (!options.silent) {
												this.trigger("reset", this,
														options)
											}
											return models
										},
										push : function(model, options) {
											return this.add(model, _.extend({
												at : this.length
											}, options))
										},
										pop : function(options) {
											var model = this
													.at(this.length - 1);
											this.remove(model, options);
											return model
										},
										unshift : function(model, options) {
											return this.add(model, _.extend({
												at : 0
											}, options))
										},
										shift : function(options) {
											var model = this.at(0);
											this.remove(model, options);
											return model
										},
										slice : function() {
											return slice.apply(this.models,
													arguments)
										},
										get : function(obj) {
											if (obj == null) {
												return void 0
											}
											return this._byId[obj]
													|| this._byId[obj.id]
													|| this._byId[obj.cid]
										},
										at : function(index) {
											return this.models[index]
										},
										where : function(attrs, first) {
											if (_.isEmpty(attrs)) {
												return first ? void 0 : []
											}
											return this[first ? "find"
													: "filter"]
													(function(model) {
														for ( var key in attrs) {
															if (attrs[key] !== model
																	.get(key)) {
																return false
															}
														}
														return true
													})
										},
										findWhere : function(attrs) {
											return this.where(attrs, true)
										},
										sort : function(options) {
											if (!this.comparator) {
												throw new Error(
														"Cannot sort a set without a comparator")
											}
											options || (options = {});
											if (_.isString(this.comparator)
													|| this.comparator.length === 1) {
												this.models = this.sortBy(
														this.comparator, this)
											} else {
												this.models.sort(_.bind(
														this.comparator, this))
											}
											if (!options.silent) {
												this.trigger("sort", this,
														options)
											}
											return this
										},
										pluck : function(attr) {
											return _.invoke(this.models, "get",
													attr)
										},
										fetch : function(options) {
											options = options ? _
													.clone(options) : {};
											if (options.parse === void 0) {
												options.parse = true
											}
											var success = options.success;
											var collection = this;
											options.success = function(resp) {
												var method = options.reset ? "reset"
														: "set";
												collection[method](resp,
														options);
												if (success) {
													success(collection, resp,
															options)
												}
												collection.trigger("sync",
														collection, resp,
														options)
											};
											wrapError(this, options);
											return this.sync("read", this,
													options)
										},
										create : function(model, options) {
											options = options ? _
													.clone(options) : {};
											if (!(model = this._prepareModel(
													model, options))) {
												return false
											}
											if (!options.wait) {
												this.add(model, options)
											}
											var collection = this;
											var success = options.success;
											options.success = function(model,
													resp) {
												if (options.wait) {
													collection.add(model,
															options)
												}
												if (success) {
													success(model, resp,
															options)
												}
											};
											model.save(null, options);
											return model
										},
										parse : function(resp, options) {
											return resp
										},
										clone : function() {
											return new this.constructor(
													this.models)
										},
										_reset : function() {
											this.length = 0;
											this.models = [];
											this._byId = {}
										},
										_prepareModel : function(attrs, options) {
											if (attrs instanceof Model) {
												return attrs
											}
											options = options ? _
													.clone(options) : {};
											options.collection = this;
											var model = new this.model(attrs,
													options);
											if (!model.validationError) {
												return model
											}
											this.trigger("invalid", this,
													model.validationError,
													options);
											return false
										},
										_addReference : function(model, options) {
											this._byId[model.cid] = model;
											if (model.id != null) {
												this._byId[model.id] = model
											}
											if (!model.collection) {
												model.collection = this
											}
											model.on("all", this._onModelEvent,
													this)
										},
										_removeReference : function(model,
												options) {
											if (this === model.collection) {
												delete model.collection
											}
											model.off("all",
													this._onModelEvent, this)
										},
										_onModelEvent : function(event, model,
												collection, options) {
											if ((event === "add" || event === "remove")
													&& collection !== this) {
												return
											}
											if (event === "destroy") {
												this.remove(model, options)
											}
											if (model
													&& event === "change:"
															+ model.idAttribute) {
												delete this._byId[model
														.previous(model.idAttribute)];
												if (model.id != null) {
													this._byId[model.id] = model
												}
											}
											this.trigger.apply(this, arguments)
										}
									});
					var methods = [ "forEach", "each", "map", "collect",
							"reduce", "foldl", "inject", "reduceRight",
							"foldr", "find", "detect", "filter", "select",
							"reject", "every", "all", "some", "any", "include",
							"contains", "invoke", "max", "min", "toArray",
							"size", "first", "head", "take", "initial", "rest",
							"tail", "drop", "last", "without", "difference",
							"indexOf", "shuffle", "lastIndexOf", "isEmpty",
							"chain", "sample" ];
					_.each(methods, function(method) {
						Collection.prototype[method] = function() {
							var args = slice.call(arguments);
							args.unshift(this.models);
							return _[method].apply(_, args)
						}
					});
					var attributeMethods = [ "groupBy", "countBy", "sortBy",
							"indexBy" ];
					_.each(attributeMethods,
							function(method) {
								Collection.prototype[method] = function(value,
										context) {
									var iterator = _.isFunction(value) ? value
											: function(model) {
												return model.get(value)
											};
									return _[method](this.models, iterator,
											context)
								}
							});
					var View = Backbone.View = function(options) {
						this.cid = _.uniqueId("view");
						options || (options = {});
						_.extend(this, _.pick(options, viewOptions));
						this._ensureElement();
						this.initialize.apply(this, arguments);
						this.delegateEvents()
					};
					var delegateEventSplitter = /^(\S+)\s*(.*)$/;
					var viewOptions = [ "model", "collection", "el", "id",
							"attributes", "className", "tagName", "events" ];
					_
							.extend(
									View.prototype,
									Events,
									{
										tagName : "div",
										$ : function(selector) {
											return this.$el.find(selector)
										},
										initialize : function() {
										},
										render : function() {
											return this
										},
										remove : function() {
											this.$el.remove();
											this.stopListening();
											return this
										},
										setElement : function(element, delegate) {
											if (this.$el) {
												this.undelegateEvents()
											}
											this.$el = element instanceof Backbone.$ ? element
													: Backbone.$(element);
											this.el = this.$el[0];
											if (delegate !== false) {
												this.delegateEvents()
											}
											return this
										},
										delegateEvents : function(events) {
											if (!(events || (events = _.result(
													this, "events")))) {
												return this
											}
											this.undelegateEvents();
											for ( var key in events) {
												var method = events[key];
												if (!_.isFunction(method)) {
													method = this[events[key]]
												}
												if (!method) {
													continue
												}
												var match = key
														.match(delegateEventSplitter);
												var eventName = match[1], selector = match[2];
												method = _.bind(method, this);
												eventName += ".delegateEvents"
														+ this.cid;
												if (selector === "") {
													this.$el.on(eventName,
															method)
												} else {
													this.$el.on(eventName,
															selector, method)
												}
											}
											return this
										},
										undelegateEvents : function() {
											this.$el.off(".delegateEvents"
													+ this.cid);
											return this
										},
										_ensureElement : function() {
											if (!this.el) {
												var attrs = _.extend({}, _
														.result(this,
																"attributes"));
												if (this.id) {
													attrs.id = _.result(this,
															"id")
												}
												if (this.className) {
													attrs["class"] = _.result(
															this, "className")
												}
												var $el = Backbone
														.$(
																"<"
																		+ _
																				.result(
																						this,
																						"tagName")
																		+ ">")
														.attr(attrs);
												this.setElement($el, false)
											} else {
												this.setElement(_.result(this,
														"el"), false)
											}
										}
									});
					Backbone.sync = function(method, model, options) {
						var type = methodMap[method];
						_.defaults(options || (options = {}), {
							emulateHTTP : Backbone.emulateHTTP,
							emulateJSON : Backbone.emulateJSON
						});
						var params = {
							type : type,
							dataType : "json"
						};
						if (!options.url) {
							params.url = _.result(model, "url") || urlError()
						}
						if (options.data == null
								&& model
								&& (method === "create" || method === "update" || method === "patch")) {
							params.contentType = "application/json";
							params.data = JSON.stringify(options.attrs
									|| model.toJSON(options))
						}
						if (options.emulateJSON) {
							params.contentType = "application/x-www-form-urlencoded";
							params.data = params.data ? {
								model : params.data
							} : {}
						}
						if (options.emulateHTTP
								&& (type === "PUT" || type === "DELETE" || type === "PATCH")) {
							params.type = "POST";
							if (options.emulateJSON) {
								params.data._method = type
							}
							var beforeSend = options.beforeSend;
							options.beforeSend = function(xhr) {
								xhr.setRequestHeader("X-HTTP-Method-Override",
										type);
								if (beforeSend) {
									return beforeSend.apply(this, arguments)
								}
							}
						}
						if (params.type !== "GET" && !options.emulateJSON) {
							params.processData = false
						}
						if (params.type === "PATCH" && noXhrPatch) {
							params.xhr = function() {
								return new ActiveXObject("Microsoft.XMLHTTP")
							}
						}
						var xhr = options.xhr = Backbone.ajax(_.extend(params,
								options));
						model.trigger("request", model, xhr, options);
						return xhr
					};
					var noXhrPatch = typeof window !== "undefined"
							&& !!window.ActiveXObject
							&& !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);
					var methodMap = {
						create : "POST",
						update : "PUT",
						patch : "PATCH",
						"delete" : "DELETE",
						read : "GET"
					};
					Backbone.ajax = function() {
						return Backbone.$.ajax.apply(Backbone.$, arguments)
					};
					var Router = Backbone.Router = function(options) {
						options || (options = {});
						if (options.routes) {
							this.routes = options.routes
						}
						this._bindRoutes();
						this.initialize.apply(this, arguments)
					};
					var optionalParam = /\((.*?)\)/g;
					var namedParam = /(\(\?)?:\w+/g;
					var splatParam = /\*\w+/g;
					var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
					_.extend(Router.prototype, Events, {
						initialize : function() {
						},
						route : function(route, name, callback) {
							if (!_.isRegExp(route)) {
								route = this._routeToRegExp(route)
							}
							if (_.isFunction(name)) {
								callback = name;
								name = ""
							}
							if (!callback) {
								callback = this[name]
							}
							var router = this;
							Backbone.history.route(route, function(fragment) {
								var args = router._extractParameters(route,
										fragment);
								router.execute(callback, args);
								router.trigger.apply(router,
										[ "route:" + name ].concat(args));
								router.trigger("route", name, args);
								Backbone.history.trigger("route", router, name,
										args)
							});
							return this
						},
						execute : function(callback, args) {
							if (callback) {
								callback.apply(this, args)
							}
						},
						navigate : function(fragment, options) {
							Backbone.history.navigate(fragment, options);
							return this
						},
						_bindRoutes : function() {
							if (!this.routes) {
								return
							}
							this.routes = _.result(this, "routes");
							var route, routes = _.keys(this.routes);
							while ((route = routes.pop()) != null) {
								this.route(route, this.routes[route])
							}
						},
						_routeToRegExp : function(route) {
							route = route.replace(escapeRegExp, "\\$&")
									.replace(optionalParam, "(?:$1)?").replace(
											namedParam,
											function(match, optional) {
												return optional ? match
														: "([^/?]+)"
											}).replace(splatParam, "([^?]*?)");
							return new RegExp("^" + route
									+ "(?:\\?([\\s\\S]*))?$")
						},
						_extractParameters : function(route, fragment) {
							var params = route.exec(fragment).slice(1);
							return _.map(params, function(param, i) {
								if (i === params.length - 1) {
									return param || null
								}
								return param ? decodeURIComponent(param) : null
							})
						}
					});
					var History = Backbone.History = function() {
						this.handlers = [];
						_.bindAll(this, "checkUrl");
						if (typeof window !== "undefined") {
							this.location = window.location;
							this.history = window.history
						}
					};
					var routeStripper = /^[#\/]|\s+$/g;
					var rootStripper = /^\/+|\/+$/g;
					var isExplorer = /msie [\w.]+/;
					var trailingSlash = /\/$/;
					var pathStripper = /#.*$/;
					History.started = false;
					_
							.extend(
									History.prototype,
									Events,
									{
										interval : 50,
										atRoot : function() {
											return this.location.pathname
													.replace(/[^\/]$/, "$&/") === this.root
										},
										getHash : function(window) {
											var match = (window || this).location.href
													.match(/#(.*)$/);
											return match ? match[1] : ""
										},
										getFragment : function(fragment,
												forcePushState) {
											if (fragment == null) {
												if (this._hasPushState
														|| !this._wantsHashChange
														|| forcePushState) {
													fragment = decodeURI(this.location.pathname
															+ this.location.search);
													var root = this.root
															.replace(
																	trailingSlash,
																	"");
													if (!fragment.indexOf(root)) {
														fragment = fragment
																.slice(root.length)
													}
												} else {
													fragment = this.getHash()
												}
											}
											return fragment.replace(
													routeStripper, "")
										},
										start : function(options) {
											if (History.started) {
												throw new Error(
														"Backbone.history has already been started")
											}
											History.started = true;
											this.options = _.extend({
												root : "/"
											}, this.options, options);
											this.root = this.options.root;
											this._wantsHashChange = this.options.hashChange !== false;
											this._wantsPushState = !!this.options.pushState;
											this._hasPushState = !!(this.options.pushState
													&& this.history && this.history.pushState);
											var fragment = this.getFragment();
											var docMode = document.documentMode;
											var oldIE = (isExplorer
													.exec(navigator.userAgent
															.toLowerCase()) && (!docMode || docMode <= 7));
											this.root = ("/" + this.root + "/")
													.replace(rootStripper, "/");
											if (oldIE && this._wantsHashChange) {
												var frame = Backbone
														.$('<iframe src="javascript:0" tabindex="-1">');
												this.iframe = frame.hide()
														.appendTo("body")[0].contentWindow;
												this.navigate(fragment)
											}
											if (this._hasPushState) {
												Backbone.$(window).on(
														"popstate",
														this.checkUrl)
											} else {
												if (this._wantsHashChange
														&& ("onhashchange" in window)
														&& !oldIE) {
													Backbone.$(window).on(
															"hashchange",
															this.checkUrl)
												} else {
													if (this._wantsHashChange) {
														this._checkUrlInterval = setInterval(
																this.checkUrl,
																this.interval)
													}
												}
											}
											this.fragment = fragment;
											var loc = this.location;
											if (this._wantsHashChange
													&& this._wantsPushState) {
												if (!this._hasPushState
														&& !this.atRoot()) {
													this.fragment = this
															.getFragment(null,
																	true);
													this.location
															.replace(this.root
																	+ "#"
																	+ this.fragment);
													return true
												} else {
													if (this._hasPushState
															&& this.atRoot()
															&& loc.hash) {
														this.fragment = this
																.getHash()
																.replace(
																		routeStripper,
																		"");
														this.history
																.replaceState(
																		{},
																		document.title,
																		this.root
																				+ this.fragment)
													}
												}
											}
											if (!this.options.silent) {
												return this.loadUrl()
											}
										},
										stop : function() {
											Backbone.$(window).off("popstate",
													this.checkUrl)
													.off("hashchange",
															this.checkUrl);
											if (this._checkUrlInterval) {
												clearInterval(this._checkUrlInterval)
											}
											History.started = false
										},
										route : function(route, callback) {
											this.handlers.unshift({
												route : route,
												callback : callback
											})
										},
										checkUrl : function(e) {
											var current = this.getFragment();
											if (current === this.fragment
													&& this.iframe) {
												current = this.getFragment(this
														.getHash(this.iframe))
											}
											if (current === this.fragment) {
												return false
											}
											if (this.iframe) {
												this.navigate(current)
											}
											this.loadUrl()
										},
										loadUrl : function(fragment) {
											fragment = this.fragment = this
													.getFragment(fragment);
											return _
													.any(
															this.handlers,
															function(handler) {
																if (handler.route
																		.test(fragment)) {
																	handler
																			.callback(fragment);
																	return true
																}
															})
										},
										navigate : function(fragment, options) {
											if (!History.started) {
												return false
											}
											if (!options || options === true) {
												options = {
													trigger : !!options
												}
											}
											var url = this.root
													+ (fragment = this
															.getFragment(fragment
																	|| ""));
											fragment = fragment.replace(
													pathStripper, "");
											if (this.fragment === fragment) {
												return
											}
											this.fragment = fragment;
											if (fragment === "" && url !== "/") {
												url = url.slice(0, -1)
											}
											if (this._hasPushState) {
												this.history[options.replace ? "replaceState"
														: "pushState"]({},
														document.title, url)
											} else {
												if (this._wantsHashChange) {
													this._updateHash(
															this.location,
															fragment,
															options.replace);
													if (this.iframe
															&& (fragment !== this
																	.getFragment(this
																			.getHash(this.iframe)))) {
														if (!options.replace) {
															this.iframe.document
																	.open()
																	.close()
														}
														this
																._updateHash(
																		this.iframe.location,
																		fragment,
																		options.replace)
													}
												} else {
													return this.location
															.assign(url)
												}
											}
											if (options.trigger) {
												return this.loadUrl(fragment)
											}
										},
										_updateHash : function(location,
												fragment, replace) {
											if (replace) {
												var href = location.href
														.replace(
																/(javascript:|#).*$/,
																"");
												location.replace(href + "#"
														+ fragment)
											} else {
												location.hash = "#" + fragment
											}
										}
									});
					Backbone.history = new History;
					var extend = function(protoProps, staticProps) {
						var parent = this;
						var child;
						if (protoProps && _.has(protoProps, "constructor")) {
							child = protoProps.constructor
						} else {
							child = function() {
								return parent.apply(this, arguments)
							}
						}
						_.extend(child, parent, staticProps);
						var Surrogate = function() {
							this.constructor = child
						};
						Surrogate.prototype = parent.prototype;
						child.prototype = new Surrogate;
						if (protoProps) {
							_.extend(child.prototype, protoProps)
						}
						child.__super__ = parent.prototype;
						return child
					};
					Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
					var urlError = function() {
						throw new Error(
								'A "url" property or function must be specified')
					};
					var wrapError = function(model, options) {
						var error = options.error;
						options.error = function(resp) {
							if (error) {
								error(model, resp, options)
							}
							model.trigger("error", model, resp, options)
						}
					};
					return Backbone
				}));
var search = {};
var main = {};
var _development = {
	logMode : SERVERNAME != "development" ? false : false,
	debugMode : SERVERNAME != "development" ? false : false,
	filter : ""
};
var BasicStatusCode = {
	404 : function() {
		if (!_development.debugMode) {
			window.location
					.replace("http://status.daum.net/error/error404.html")
		} else {
			alert("404에러")
		}
	},
	400 : function() {
		if (!_development.debugMode) {
			window.location
					.replace("http://status.daum.net/error/error404.html")
		} else {
			alert("400에러")
		}
	},
	401 : function() {
		window.location.href = "http://login.daum.net/accounts/loginform.do?url="
				+ encodeURIComponent(location.href)
	},
	403 : function() {
		if (!_development.debugMode) {
			window.location
					.replace("http://status.daum.net/error/error403.html")
		} else {
			alert("403에러")
		}
	},
	500 : function() {
		if (!_development.debugMode) {
			window.location
					.replace("http://status.daum.net/error/error500.html")
		} else {
			alert("500에러")
		}
	}
};
var CustomStatusCode = {
	403 : function(resp) {
		if (resp.desc == "ADULT") {
			window.location.href = resp.adultUrl
					+ encodeURIComponent("http://"
							+ location.hostname
							+ "/main/redirect.daum?hascode="
							+ encodeURIComponent(location.hash
									.replace("#!", "")))
		} else {
			BasicStatusCode[403]()
		}
	}
};
(function($) {
	var shopping = {};
	shopping.local = {};
	shopping.routes = {};
	shopping.views = {};
	shopping.apis = {};
	shopping.apiVersion = {};
	shopping.mainApi = [ "category", "top", "search" ];
	shopping.apiRoot = {
		likeness : "/product/likeness.json",
		category : "/category.json",
		categoryAll : "/categoryAll.json",
		search : "/product/search.json",
		top : "/top.json",
		topLeft : "/topLeft.json",
		topRight : "/topRight.json",
		preview : "/product/preview.json",
		searchItem : "/product/searchItem.json",
		footer : "/footer.json",
		shoppingGuide : "/product/shoppingGuide.json",
		colorHolic : "/colorHolic.json",
		rightwing : "/rightwing.json",
		delzzimprod : "/delzzimprod.json",
		delrecentproduct : "/delrecentproduct.json",
		delrecentshopping : "/delrecentshopping.json",
		getbrandlink : "/brand/getbrandlink.json",
		detailCommon : "/product/detailCommon.json",
		detailTop : "/product/detailTop.json",
		detailTopRight : "/product/detailTopRight.json",
		detailTab : "/product/detailTab.json",
		detailInfo : "/product/detailInfo.json",
		detailReview : "/product/detailReview.json",
		detailCompare : "/product/detailCompare.json",
		detailTrend : "/product/detailTrend.json",
		detailExpert : "/product/detailExpert.json",
		detailMultimedia : "/product/detailMultimedia.json",
		detailGuide : "/product/detailGuide.json",
		playDetailTop : "/play/detailTop.json",
		playDetailTopRight : "/play/detailTopRight.json",
		playDetailInfo : "/play/detailInfo.json",
		playDetailCompare : "/play/detailCompare.json",
		playDetailExpert : "/play/detailExpert.json",
		playDetailMultimedia : "/play/detailMultimedia.json",
		reviewCheckLogin : "/review/checkLogin.json",
		writeUserReview : "/review/writeUserReview.json",
		deleteUserReview : "/review/deleteUserReview.json",
		shoppingbox : "/todayshopping.json",
		department : "/department.json",
		recomProdList : "/product/recomProdListTab.json",
		mypeertotal : "/mypeertotalByDL.json",
		mypeer : "/mypeer.json",
		mypeerproduct : "/mypeerproductByDL.json",
		mPlanningShow : "/mini/planningshow.json",
		mPlanningShowAll : "/mini/planningshowall.json",
		mPlanningShowCate : "/mini/planningshowCate.json",
		mStarshop : "/mini/starshop.json",
		mStarshopAll : "/mini/starshopall.json",
		mShoppingPartner : "/mini/shoppingpartner.json",
		mTop : "/mini/top.json",
		mTopBottom : "/mini/top_bottom.json",
		mTrend : "/mini/todayshopping.json",
		mAddZzim : "/mini/addzzim.json",
		mCategory : "/mini/category.json",
		mGnb : "/mini/gnb.json",
		mTvList : "/mini/tvlist.json",
		mTvListDetail : "/mini/tvlistdetail.json",
		mTvProdList : "/mini/tvprodlist.json",
		mMyZzim : "/mini/zzimList.json",
		mMyLatest : "/mini/recentList.json",
		mMySoho : "/mini/sohoroomList.json",
		mForuEvent : "/mini/foru.json",
		navigatorPartner : "/navigatorPartner.json",
		bestshoprecomm : "/bestShopRecomm.json",
		eventList : "/eventList.json",
		eventDetail : "/eventDetail.json",
		categoryEventList : "/categoryEventList.json",
		mallEventList : "/mallEventList.json",
		leftWing : "/leftwing.json",
		mDetailCommon : "/mini/product/detailCommon.json",
		mDetailTop : "/mini/product/detailTop.json",
		mDetailRelative : "/mini/product/detailRelativeProduct.json",
		mDetailSpec : "/mini/product/detailSpec.json",
		mDetailInfo : "/mini/product/detailInfo.json",
		mDetailReview : "/mini/product/detailReview.json",
		mDetailCompare : "/mini/product/detailCompare.json",
		mDetailChartImage : "/mini/product/detailChartImage.json",
		mDetailReview : "/mini/product/detailReview.json",
		mDetailGuide : "/mini/product/detailGuide.json",
		mDetailTopCompare : "/mini/product/detailTopCompare.json",
		checkUserInfo : "/review/checkUser.json",
		mDetailReviewContent : "/mini/product/detailReviewContent.json",
		mPlayDetailTop : "/mini/play/detailTop.json",
		mPlayRelative : "/mini/play/detailRelativeProduct.json",
		mPlayDetailInfo : "/mini/play/detailInfo.json",
		mPlayDetailCompare : "/mini/play/detailCompare.json",
		mPlayDetailMultimedia : "/mini/play/detailMultimedia.json",
		mPlayDetailCoupon : "/mini/product/detailCoupon.json",
		mPlayDetailTopCompare : "/mini/play/detailTopCompare.json",
		mSpecialPrice : "/mini/specialprice.json",
		mHotdeal : "/mini/hotdeal.json",
		mTodayBest100 : "/mini/todaybest100.json",
		mCategoryBest100 : "/mini/categorybest100.json",
		mCategoryBest100List : "/mini/categorybest100list.json",
		mRecentShopping : "/mini/recentshoppingbox.json",
		mPlusshopMain : "/mini/plusshopmain.json",
		mPlusshopDetail : "/mini/plusshopdetail.json",
		mDefaultFlicking : "/mini/defaultFlicking.json",
		mileageSearchProdList : "/mileage/searchprod.json",
		mileageSearchExtProdList : "/mileage/searchextprod.json",
		mEventToday : "/mini/plannigToday.json",
		mEventSoho : "/mini/plannigPopular.json",
		mEventMatch : "/mini/plannigMatch.json",
		mEventOrder : "/mini/planningOrder.json",
		similarImageProd : "/product/similarimageprodlist.json"
	};
	shopping.preventParams = {
		fullName : ""
	};
	_.each(shopping.apiRoot, function(value, key) {
		shopping.apis[key] = (window.DAUM_SHOPPING_URL || "/")
				+ (window.SHOPPING_API_VERSION[key] || "v1.0")
				+ shopping.apiRoot[key]
	});
	window.Shopping = shopping
})(jQuery);
(function() {
	var Tico = null, USE = false, DEBUG_MODE = false, USERID = "", SERVICE_CODE = "", PARAMS = {}, UA = "", REFERER = "", MSIE = "Y";
	try {
		UA = window.navigator.userAgent;
		REFERER = document.referrer;
		MSIE = UA.indexOf("MSIE") > -1 ? "Y" : "N"
	} catch (e) {
	}
	try {
		Tico = function() {
			var instance = null;
			var _Tico = function() {
				this.version = "0.1"
			};
			_Tico.prototype = {
				start : function(opt) {
					var opt = opt || {};
					USE = true;
					DEBUG_MODE = opt.DEBUG_MODE || false;
					SERVICE_CODE = opt.SERVICE_CODE || ""
				},
				stop : function() {
					USE = false;
					SERVICE_CODE = "";
					DEBUG_MODE = false
				},
				setParams : function(params) {
					extend(PARAMS, params, true)
				},
				send : function(e, key, params) {
					if (USE) {
						try {
							var error = e || {};
							var object = this._createObject(error, key, params);
							var serializedString = this._serialize(object);
							var output = "http://group1.magpie.daum.net/magpie/put/"
									+ SERVICE_CODE + "?" + serializedString;
							if (DEBUG_MODE) {
								console[console.error ? "error" : "log"](
										window.___tico_error = e,
										window.___tico_output = output)
							} else {
								var image = new Image();
								image.src = output
							}
						} catch (ex) {
						}
					} else {
						throw e
					}
				},
				getErrorType : function(type) {
					var t = Tico.TYPE;
					for ( var p in type) {
						if (t.hasOwnProperty(p)) {
							if (t[p] == type) {
								return p
							}
						}
					}
					return Tico.TYPE_DEFAULT
				},
				setErrorType : function(code, type) {
					Tico.TYPE[type] = code
				},
				_createObject : function(error, key, params) {
					return extend(extend({
						message : error.message || "-",
						stack : error.stack || "-",
						stackTrace : error.stackTrace || "-",
						errorCode : error.errorCode || "0",
						TYPE : this.getErrorType(params.TYPE)
								|| this.getErrorType(Tico.TYPE.CATCH_ERROR),
						UA : UA || "-",
						REFERER : REFERER || "-",
						KEY : key || "-",
						MSIE : MSIE || "-"
					}, PARAMS, false), params, false)
				},
				_serialize : function(obj) {
					var plist = [];
					for ( var p in obj) {
						if (obj.hasOwnProperty(p)) {
							try {
								var value = obj[p];
								if (JSON && (typeof obj[p] == "object")) {
									value = JSON.stringify(obj[p])
								}
								plist.push(p + "=" + encodeURIComponent(value))
							} catch (ex) {
							}
						}
					}
					return plist.join("&")
				}
			};
			var extend = function(dest, source, overwrite) {
				var ow = overwrite !== undefined ? overwrite : true, p;
				for (p in source) {
					if (!dest[p] || ow) {
						dest[p] = source[p]
					}
				}
				return dest
			};
			return {
				getInstance : function() {
					if (instance) {
						return instance
					}
					return instance = new _Tico()
				}
			}
		}();
		Tico.TYPE = {
			GLOBAL_ERROR : 100,
			AJAX_ERROR : 101,
			AJAX_CALLBACK_ERROR : 102,
			CATCH_ERROR : 103,
			LISTENER_ERROR : 104,
			LOG : 105
		};
		Tico.TYPE_DEFAULT = "GLOBAL_ERROR"
	} catch (e) {
		Tico = {
			getInstance : {
				start : function() {
				},
				stop : function() {
				},
				send : function() {
				},
				setParams : function() {
				}
			}
		}
	}
	window.Tico = Tico
})();
(function($) {
	if (SERVERNAME == "front") {
		Tico.getInstance().start({
			SERVICE_CODE : "shopping_ft",
			DEBUG_MODE : _development.debugMode
		});
		window.onerror = function(errorMsg, url, linenum) {
			var event = window.event || {};
			var stack = errorMsg + "\nat " + url + ":" + linenum + ":1";
			if (event.errorUrl) {
				stack = event.errorMessage + "\nat " + event.errorUrl + ":"
						+ event.errorLine + ":" + event.errorCharacter
			}
			var ex = {
				message : event.errorMessage || errorMsg,
				stack : stack
			};
			Tico.getInstance().send(ex, "GlobalError", {
				TYPE : Tico.TYPE.GLOBAL_ERROR,
				url : document.location.href
			});
			return true
		};
		$(document).ajaxError(function(e, jqxhr, settings, exception) {
			Tico.getInstance().send(exception, "GlobalError", {
				TYPE : Tico.TYPE.AJAX_ERROR,
				settings : settings,
				url : settings.url
			})
		})
	}
})(jQuery);
(function($) {
	window.setViewInstance = function(instance, view, options, pick) {
		var prevParam, param, name = options.name;
		delete options.name;
		if (!instance[name]) {
			s_console.debug("setViewInstance", name, options);
			instance[name] = new view(options);
			return true
		} else {
			prevParam = _.pick(instance[name].options, pick);
			param = _.pick(options, pick);
			_.extend(instance[name].options, options);
			return !_.isEqual(prevParam, param)
		}
	};
	window.s_console = {
		log : function() {
			if (_development.logMode) {
				try {
					if (_.include(arguments, _development.filter)
							|| _development.filter == "") {
						console.log(arguments)
					}
				} catch (e) {
				}
			}
		},
		debug : function() {
			if (_development.debugMode) {
				try {
					if (_.include(arguments, _development.filter)
							|| _development.filter == "") {
						console.log(">>>>>DEBUG<<<<<", arguments)
					}
				} catch (e) {
				}
			}
		}
	};
	window.isLocalStorage = function() {
		try {
			window.localStorage.setItem("test", "1");
			window.localStorage.removeItem("test");
			return true
		} catch (error) {
			return false
		}
	}();
	window.SetFix = function(el, options) {
		s_console.log("sexfix");
		if ($.fn.jquery.indexOf("1") == 0) {
			this.useFix = $.support.boxModel
		} else {
			this.useFix = true
		}
		this.option = null;
		this.$el = null;
		this.fix = null;
		this.min = null;
		var date = new Date();
		this.eventId = date.getTime() % 100;
		this.originTop = 0;
		this.reset(el, options)
	};
	_
			.extend(
					SetFix.prototype,
					{
						reset : function(el, options) {
							if (this.el == el) {
								return false
							}
							options = options || {};
							this.el = el;
							this.$el = $(el);
							this.setOriginPosition();
							var offset = this.$el.offset();
							this.min = options.fixtoMin || offset.top;
							this.fixLeft = options.fixLeft
									|| (offset.left - ($("body").outerWidth() / 2));
							this.fixTop = options.fixTop || 0;
							this.setOption(options);
							if ((this.min >= this.max)
									&& ($(window).height() <= this.$el.height())) {
								this.removefix()
							} else {
								this.setfix()
							}
						},
						setOriginPosition : function() {
							this.originTop = isNaN(parseInt(
									this.$el.css("top"), 10)) ? 0 : parseInt(
									this.$el.css("top"), 10);
							this.originLeft = this.$el.css("left") == "auto" ? this.$el
									.position().left
									: this.$el.css("left");
							this.originPosition = this.$el.css("position");
							this.originMargin = this.$el.css("margin-left")
						},
						setOption : function(options) {
							this.toption = options ? _.clone(options) : {};
							this.fixLeft = this.toption.fixLeft || this.fixLeft;
							this.fixTop = _.isUndefined(this.toption.fixTop) ? this.fixTop
									: this.toption.fixTop;
							this.min = _.isUndefined(this.toption.fixtoMin) ? this.min
									: this.toption.fixtoMin;
							this.max = _.isUndefined(this.toption.fixtoMax) ? 9999999
									: this.toption.fixtoMax;
							this.maxTop = _.isUndefined(this.toption.maxTop) ? this.max
									: this.toption.maxTop;
							this.changePosition()
						},
						setfix : function() {
							this.removefix();
							$(window).on("scroll.setFix" + this.eventId,
									_.bind(this.changePosition, this))
						},
						removefix : function() {
							$(window).off("scroll.setFix" + this.eventId)
						},
						changePosition : function() {
							var scroll = 0;
							if (this.useFix) {
								scroll = $(window).scrollTop()
							} else {
								scroll = $("body").scrollTop()
							}
							if (this.min < scroll && this.min < this.max
									&& scroll <= this.max) {
								if (this.useFix) {
									this.$el.css({
										position : "fixed",
										top : this.fixTop,
										left : "50%",
										marginLeft : this.fixLeft
									})
								} else {
									var endPosition = this.originPosition;
									if (endPosition != "absolute"
											&& endPosition != "relative") {
										endPosition = "absolute"
									}
									this.$el.css({
										position : endPosition,
										top : this.originTop
												+ (scroll - this.min),
										left : this.originLeft
									})
								}
							} else {
								if (this.min >= scroll || this.min >= this.max) {
									this.$el.css({
										position : this.originPosition,
										top : this.originTop,
										left : this.originLeft,
										marginLeft : this.originMargin
									})
								} else {
									if (this.max <= scroll
											&& this.min <= scroll) {
										var endPosition = this.originPosition;
										if (endPosition != "absolute"
												&& endPosition != "relative") {
											endPosition = "absolute"
										}
										this.$el.css({
											position : endPosition,
											top : this.maxTop,
											left : this.originLeft,
											marginLeft : this.originMargin
										})
									}
								}
							}
						}
					});
	window.getOptParam = function(opt, key, defaults) {
		if (_.isUndefined(opt) || _.isEmpty(opt)) {
			return defaults || ""
		} else {
			opt = _.reject(opt.split("&"), function(item) {
				return _.isUndefined(_.find(opt.split("&"), function(item) {
					return item.indexOf(key) == 0
				}))
			});
			if (_.size(opt) > 0) {
				return _.find(opt, function(item) {
					return item.indexOf(key) == 0
				}).replace(key + ":", "")
			} else {
				return defaults || ""
			}
		}
	};
	window.localJson = {
		hasLocal : (function() {
			try {
				return window.localStorage ? true : false
			} catch (e) {
				return false
			}
		})(),
		getJson : function(apiname, options) {
			var data = false;
			var option = options || {};
			if (this.hasLocal && !this.isChanged(apiname, option)) {
				data = JSON.parse(window.localStorage.getItem(apiname))
			} else {
				if (Shopping.local[apiname]) {
					data = JSON.parse(Shopping.local[apiname])
				}
			}
			if (data === null || data === "") {
				data = false
			}
			s_console.log("localStorage", apiname);
			return data
		},
		setJson : function(apiname, json) {
			if (this.hasLocal) {
				try {
					s_console.log("setLocalStorage", apiname);
					window.localStorage.setItem(apiname, json);
					window.localStorage.setItem(apiname + "_version",
							Shopping.apiVersion[apiname])
				} catch (e) {
					if (e.code == 22) {
						s_console.log("웹 스토리지가 .....다 참..")
					}
				}
			} else {
				Shopping.local[apiname] = json
			}
		},
		isChanged : function(apiname, options) {
			var check = options.nocheck || false;
			if (check
					|| (window.localStorage.getItem(apiname + "_version") != Shopping.apiVersion[apiname])) {
				return true
			} else {
				return false
			}
		}
	};
	window.toDateExp = function(DateString, FormatString) {
		var localstring = FormatString || "yyyy.MM.dd";
		var str = "";
		if (DateString && DateString !== "") {
			if (typeof (DateString) === "string") {
				DateString = DateString.replace(/(\.|-)/g, "");
				str = localstring.replace(/(yyyy|yy|MM|dd|hh|mm|ss)/gi,
						function($1) {
							switch ($1) {
							case "yyyy":
								return DateString.substring(0, 4);
							case "yy":
								return DateString.substring(2, 4);
							case "MM":
								return DateString.substring(4, 6);
							case "dd":
								return DateString.substring(6, 8);
							case "hh":
								return DateString.substring(8, 10);
							case "mm":
								return DateString.substring(10, 12);
							case "ss":
								return DateString.substring(12, 14)
							}
						})
			} else {
				str = localstring
						.replace(
								/(yyyy|yy|MM|dd|E|hh|mm|ss|a\/p)/gi,
								function($1) {
									switch ($1) {
									case "yyyy":
										return DateString.getFullYear();
									case "yy":
										return zerofill(DateString
												.getFullYear() % 1000);
									case "MM":
										return zerofill((DateString.getMonth() + 1));
									case "dd":
										return zerofill(DateString.getDate());
									case "hh":
										return zerofill(DateString.getHours());
									case "mm":
										return zerofill(DateString.getMinutes());
									case "ss":
										return zerofill(DateString.getSeconds());
									default:
										return $1
									}
								})
			}
		}
		return str
	};
	window.zerofill = function(value) {
		var num = +value;
		return num < 10 ? "0" + num : num
	};
	window.compare = function(id) {
		var compareBox = setViewInstance(Shopping.views.search.childView,
				CompareBoxView, {
					name : "compareBox"
				});
		if (compareBox || $("#compareBox").is(":hidden")) {
			$("#compareBox").show();
			Shopping.views.search.childView.compareBox.render().add(id)
		} else {
			Shopping.views.search.childView.compareBox.add(id)
		}
	};
	window.realsize = function(id) {
		var uAgent = navigator.userAgent.toLowerCase();
		var nonflash = new Array("iphone", "ipod", "ipad", "android",
				"blackberry", "windows ce", "nokia", "webos", "opera mini",
				"sonyericsson", "opera mobi", "iemobile");
		for (var i = 0; i < nonflash.length; i++) {
			if (uAgent.indexOf(nonflash[i]) != -1) {
				alert("PC에서만 보실수 있습니다.");
				return
			}
		}
		window.open(
				"http://imgshop.hanmail.net/realgallery/page/real.htm?guid="
						+ id, "RealSize")
	};
	window.popup = function(url, name, specs) {
		window.open(url, name, specs)
	};
	window.setFavorite = function() {
		var title = "Daum쇼핑은 쇼핑하우입니다.";
		var url = "http://shopping.daum.net";
		if (ua_result.browser.firefox) {
			if (window.sidebar && window.sidebar.addPanel) {
				window.sidebar.addPanel(title, url, "")
			} else {
				alert("Ctrl + D를 눌러서 추가해주세요")
			}
		} else {
			if (ua_result.browser.opera) {
				var elem = document.createElement("a");
				elem.setAttribute("href", url);
				elem.setAttribute("title", title);
				elem.setAttribute("rel", "sidebar");
				elem.click()
			} else {
				if (ua_result.browser.msie) {
					window.external.AddFavorite(url, title)
				} else {
					if (ua_result.browser.chrome) {
						alert("Ctrl + D를 눌러서 추가해주세요")
					}
				}
			}
		}
	};
	window.spopup = function(url, name, w, h, scroll) {
		var tmpV = "width=" + w + ",height=" + h + ",resizable=yes,scrollbars="
				+ scroll;
		openWindow = window.open(url, name, tmpV);
		openWindow.focus()
	};
	window.goModelDetail = function(modelid) {
		var url = "/product/#!/" + modelid;
		window.open(url)
	};
	window.showDetailDistBarChart = function(type, min, max) {
		var data = Shopping.views.detailMain.model.get("common");
		chartPriceDist(type, data.cateid, data.prodid, data.subcode, min, max,
				"", "detailDistChartDiv");
		$(".desc_similar").show()
	};
	window.chartPriceTrend = function(type, modelid, grouptypeid, term, divId,
			viewType) {
		var fchart = null;
		var url = "/v1.0/priceTrend.json";
		var data = {
			modelid : modelid,
			grouptypeid : grouptypeid,
			term : term,
			type : type,
			viewType : viewType
		};
		chartPrice(url, data, divId)
	};
	window.chartPriceDist = function(type, cateid, modelid, grouptypeid, min,
			max, limit, divId) {
		var size = "";
		if (type == "cateDistBarSmall") {
			type = "cateDistBar";
			size = "s"
		}
		var url = "/v1.0/priceDist.json";
		var data = {
			cateid : cateid,
			type : type,
			modelid : modelid,
			grouptypeid : grouptypeid,
			minprice : min,
			maxprice : max,
			size : size,
			limit : limit
		};
		chartPrice(url, data, divId, type)
	};
	window.chartPrice = function(url, data, divId, type) {
		jQuery.ajax({
			url : url,
			data : data
		}).done(
				function(result) {
					if (divId) {
						renderFlotChart(result.chartList, divId, result.opt,
								result.addInfoList, type)
					}
				})
	};
	window.renderFlotChart = function(result, divId, opt, addData, type) {
		if (!type || type == "cateDistNew") {
			opt.yaxis.tickFormatter = function(e) {
				return __.toNumberExp(e) + "원"
			}
		}
		try {
			var plot = jQuery.plot("#" + divId, result, opt);
			if (divId == "interTrend") {
				$("#interTrend").bind("plothover", function(event, pos, item) {
					if (item) {
						var d = new Date(item.datapoint[0]);
						var x = (d.getMonth() + 1) + "월" + (d.getDate()) + "일";
						y = __.toNumberExp(item.datapoint[1]);
						$("#tooltip").html(x + "  " + y + "원").css({
							top : item.pageY - 27,
							left : item.pageX - 27,
							border : "1px solid #050505",
							"background-color" : "#f8f8f8"
						}).fadeIn(200)
					} else {
						$("#tooltip").hide()
					}
				})
			}
			if (divId == "popCategoryChart") {
				$("#popCategoryChart").bind(
						"plothover",
						function(event, pos, item) {
							if (item) {
								var x = item.datapoint[0];
								var modelname = addData[x - 1][1];
								y = __.toNumberExp(item.datapoint[1]);
								$("#tooltip").html(
										x + "위  " + modelname + " " + y
												+ "원<p>상품보기 클릭!").css({
									top : item.pageY - 45,
									left : item.pageX - 45,
									border : "1px solid #050505",
									"background-color" : "#f8f8f8"
								}).fadeIn(200)
							} else {
								$("#tooltip").hide()
							}
						});
				$("#popCategoryChart").bind("plotclick",
						function(event, pos, item) {
							if (item) {
								var x = item.datapoint[0];
								x = x - 1;
								var modelid = addData[x][2];
								goModelDetail(modelid)
							}
						})
			}
			if (divId == "similarChart") {
				$("#similarChart").bind(
						"plothover",
						function(event, pos, item) {
							if (item) {
								var x = __.toNumberExp(item.datapoint[0]);
								var y = item.datapoint[1];
								$("#tooltip").html(
										y + "개 " + x + "원대<p>현재 구간 상세보기 클릭!")
										.css({
											top : item.pageY - 30,
											left : item.pageX - 30,
											border : "1px solid #050505",
											"background-color" : "#f8f8f8"
										}).fadeIn(200)
							} else {
								$("#tooltip").hide()
							}
						});
				$("#similarChart").bind("plotclick",
						function(event, pos, item) {
							if (item) {
								var min = 0;
								max = 0;
								var selectData = item.datapoint[0];
								for (var i = 0; i < addData.length; i++) {
									if (addData[i][0] == selectData) {
										min = addData[i][0];
										max = addData[i][1]
									}
								}
								showDetailDistBarChart(type, min, max)
							}
						})
			}
		} catch (e) {
			$("#" + divId)
					.parent()
					.html(
							'<span style="display:block;text-align:center;position:absolute;left:50%;top:50%;margin-top:-9px;margin-left:-88px">아직 데이터가 준비되지 않았습니다.</span>')
		}
	};
	window.__ = {
		getProductImageUrl : function(adultUrl, type, uptime, id) {
			if (adultUrl && adultUrl.indexOf("http://") >= 0) {
				return (adultUrl.indexOf("/img/19_") >= 0) ? adultUrl.replace(
						"_160", "_" + type) : adultUrl
			}
			var isMobile = navigator.userAgent.toLowerCase()
					.match(".*mobile.*") ? true : false;
			var subDomain = (isMobile ? "m" : "t")
					+ (parseInt(id.substring(id.length - 1)) % 2 + 1);
			var ut = uptime ? "?ut=" + uptime : "?ut="
					+ toDateExp(new Date(), "yyyyMM");
			var url = "http://t" + subDomain.substring(1)
					+ ".shop.daumcdn.net/shophow/p/" + id + ".jpg" + ut;
			var size = "R" + type + "x" + type;
			var thumbnail = "http://" + subDomain + ".daumcdn.net/thumb/"
					+ size + "/?fname=";
			return thumbnail + encodeURIComponent(url)
		},
		getContentImageUrl : function(path) {
			var isMobile = navigator.userAgent.toLowerCase()
					.match(".*mobile.*") ? true : false;
			var subDomain = (isMobile ? "m" : "t") + (path.length % 2 + 1);
			var url = "http://" + subDomain + (isMobile ? "" : ".shop")
					+ ".daumcdn.net/shophow/c" + path;
			return url
		},
		getProdImageUrl : function(imgURL, size, ut, id, type) {
			if (imgURL && imgURL.indexOf("http://") >= 0) {
				return (imgURL.indexOf("/img/19_") >= 0) ? imgURL.replace(
						"_160", "_" + size) : imgURL
			}
			var cdnServer = ((__.isMobile()) ? "m" : "i")
					+ (parseInt(id.substring(1, (id + "_").indexOf("_")) % 2) + 1);
			imgURL = "http://i1.daumcdn.net/svc/image/U03/shophow/" + id
					+ ".jpg?ut=" + (ut || toDateExp(new Date(), "yyyyMM"));
			if (type) {
				var sizeStr = "";
				if (_.isObject(size)) {
					sizeStr = type + size.width + "x" + size.height
				} else {
					sizeStr = (type + size + "x" + size)
				}
				size = (!size) ? type + "120x120" : sizeStr
			} else {
				size = (!size) ? "R120x120" : ("R" + size + "x" + size)
			}
			return "http://" + cdnServer + ".daumcdn.net/thumb/" + size
					+ "/?fname=" + encodeURIComponent(imgURL)
		},
		getThumbImageUrl : function(size, quality, url, isOrigin) {
			size = Math.round(size / 10) * 10;
			return (isOrigin) ? url : "http://m1.daumcdn.net/thumb/R" + size
					+ "x" + size + ((quality >= 100) ? "" : (".q" + quality))
					+ "/?fname=" + url
		},
		toNumberExp : function(value) {
			if (_.isUndefined(value) || _.isNull(value)) {
				return ""
			}
			value = parseInt(value) + "";
			var retstr = "";
			for (var i = value.length - 1, j = 0; i >= 0; i--, j++) {
				if (j != 0 && j % 3 == 0) {
					retstr = "," + retstr
				}
				retstr = value.charAt(i) + retstr
			}
			return retstr
		},
		cutString : function(s, limit, suff, tagremove) {
			if (_.isEmpty(s)) {
				return ""
			}
			if (tagremove === true) {
				s = s.replace(
						/<(\/)?([a-zA-Z]*)(\s[a-zA-Z]*=[^>]*)?(\s)*(\/)?>/gi,
						"")
			}
			var suffix = suff || "", _limit = limit - suffix.length, _byte = 0, _str = "", temp;
			_.each(s.toString().split(""), function(chr) {
				temp = (escape(chr).length > 3) ? 2 : 1;
				_byte += temp;
				_limit -= temp;
				if (_limit >= 0) {
					_str += chr
				}
			});
			return (limit >= _byte) ? s : _str += suffix
		},
		getByteLength : function(s) {
			var _length = 0;
			_.each(s.toString().split(""), function(chr) {
				_length += (escape(chr).length > 3) ? 2 : 1
			});
			return _length
		},
		chunk : function(list, range, rowChunk) {
			var tempArray;
			var chunkArray = [];
			if (!_.isEmpty(list)) {
				var il = list.length;
				var increse = 0;
				var i = 0;
				if (!rowChunk) {
					increse = Math.floor(il / range) || 1;
					var max = 0;
					if (il / increse > range) {
						max = (il % range) * (increse + 1)
					}
					increse += 1;
					while (i < il) {
						if (i == max) {
							increse -= 1
						}
						tempArray = list.slice(i, i + increse);
						chunkArray.push(tempArray);
						i += increse
					}
				} else {
					for (; i < il; i += range) {
						chunkArray.push(list.slice(i, i + range))
					}
				}
			}
			return chunkArray
		},
		brandchunk : function(list, range) {
			var chunkArray = [], tmpArray = [], d = 0;
			while (d < range) {
				chunkArray.push([]);
				d++
			}
			d = 0;
			_.each(list, function(t, i) {
				if (t.depth == 0 && i != 0) {
					if (!_.isEmpty(tmpArray)) {
						chunkArray[d].push(tmpArray);
						tmpArray = []
					}
					d = (d == 3) ? 0 : d + 1
				}
				tmpArray.push(t)
			});
			if (!_.isEmpty(tmpArray)) {
				chunkArray[d].push(tmpArray)
			}
			return chunkArray
		},
		getErrorImage : function(size, errorurl) {
			if (errorurl && errorurl != null) {
				return errorurl
			}
			var imgsize = parseInt(size, 10);
			if (imgsize == 100) {
				imgsize = "100x70"
			} else {
				if (imgsize <= 150) {
					imgsize = 120
				} else {
					if (imgsize > 150 && imgsize <= 230) {
						imgsize = 200
					} else {
						if (imgsize > 230 && imgsize <= 300) {
							imgsize = 270
						} else {
							imgsize = 500
						}
					}
				}
			}
			return "http://i1.daumcdn.net/imgsrc.search/shopping/v2/thumb/noimg_"
					+ imgsize + ".gif"
		},
		isMobile : function() {
			var ua = navigator.userAgent.toLowerCase();
			return (ua.match(".*mobile.*")) ? true : false
		},
		getProdName : function(obj) {
			var maker = obj.maker;
			var isModel = obj.isModel || "Y";
			var brand = obj.brand;
			var name = obj.name;
			var nick = obj.nick;
			name = name.replace(/<|>/g, "/");
			var resultName = "";
			if (isModel && isModel == "N") {
				resultName = name
			} else {
				if (!_.isEmpty(brand) || !_.isEmpty(maker)) {
					var reg = new RegExp("(" + brand + "|" + maker + ")", "g");
					if (reg.test(name)) {
						resultName = name
					} else {
						if (!_.isEmpty(maker)) {
							resultName = maker + " "
						}
						if (!_.isEmpty(brand)) {
							resultName += brand + " "
						}
						resultName += name;
						if (!_.isEmpty(nick)) {
							resultName = nick + " " + resultName
						}
					}
				} else {
					resultName = name
				}
			}
			return _.escape(resultName)
		},
		chunkEach : function(list, range, rowChunk, iterator, context) {
			var subList = [];
			var runIterator = iterator;
			if (!_.isFunction(rowChunk)) {
				subList = this.chunk(list, range, rowChunk)
			} else {
				subList = this.chunk(list, range);
				runIterator = rowChunk;
				context = iterator
			}
			_.each(subList, runIterator, context)
		},
		inserTabViewHtml : function(currentTab) {
			var temp = Shopping.views.detailMain.childView.detailTab;
			temp.render(currentTab);
			return temp.$el.html()
		},
		rdm : function(val) {
			return Math.round(Math.random() * val)
		},
		pickRandom : function(list, cnt, defaultlist) {
			var pickArray = [];
			if (!_.isArray(defaultlist) && !_.isUndefined(defaultlist)) {
				if (_.isString(defaultlist) && defaultlist.indexOf(",") >= 0) {
					pickArray = defaultlist.split(",")
				} else {
					pickArray = [ defaultlist ]
				}
			} else {
				if (_.isArray(defaultlist)) {
					pickArray = defaultlist
				}
			}
			if (_.size(list) > 0) {
				var range = _.range(_.size(list));
				var rangeArray = _.clone(range);
				var pickupRange = function() {
					rangeArray = _.difference(range, pickArray);
					pickArray
							.push(rangeArray[_.random(_.size(rangeArray) - 1)]);
					if (_.size(pickArray) < cnt) {
						pickupRange()
					}
				};
				pickupRange()
			}
			return pickArray
		},
		getMoibleDetailUrl : function(prodid, subcode) {
			var url = location.pathname + "#!/detail/" + prodid;
			if (!_.isEmpty(subcode)) {
				url += "/subcode:" + subcode
			}
			return url
		},
		getMoibleDetailEtcUrl : function(type, prodid, subcode) {
			var url = MOBILEPATH + type + ".daum?productid=" + prodid;
			if (!_.isEmpty(subcode)) {
				url += "&subcode=" + subcode
			}
			return url + "&appcode=PROD"
		},
		eachmax : function(obj, limit, iterator, context) {
			var breaker = {};
			var length = (limit > obj.length) ? obj.length : limit;
			if (obj == null) {
				return
			}
			if (obj.length === +obj.length) {
				for (var i = 0, l = length; i < l; i++) {
					if (i in obj
							&& iterator.call(context, obj[i], i, obj) === breaker) {
						return
					}
				}
			} else {
				var index = 0;
				for ( var key in obj) {
					if (_.has(obj, key) && index <= limit) {
						if (iterator.call(context, obj[key], key, obj) === breaker) {
							return
						}
						index++
					}
				}
			}
		},
		hasContent : function(obj) {
			try {
				if (!_.isNull(obj) && !_.isEmpty(obj)) {
					return true
				} else {
					return false
				}
			} catch (e) {
				return false
			}
		},
		getDeliPrice : function(deli) {
			deli = deli + "";
			var deliinfo = deli.split("_");
			var type = _.first(deliinfo);
			var price = _.last(deliinfo);
			var deliValue = "";
			if (type == "0") {
				deliValue = "무료배송"
			} else {
				if (type == "2") {
					deliValue = "조건부 무료"
				} else {
					if (type == "1") {
						if (_.isNaN(parseInt(price, 10))) {
							deliValue = "유료배송"
						} else {
							deliValue = parseInt(price, 10) + "원"
						}
					} else {
						deliValue = "무료배송"
					}
				}
			}
			return deliValue
		},
		getRevewRating : function(rate) {
			var tempRate = parseFloat(rate);
			var rating = tempRate > 5 ? 5 : tempRate;
			return (rating * 20) + "%"
		},
		_unescape : {
			unescape : {
				"&amp;" : "&",
				"&lt;" : "<",
				"&gt;" : ">",
				"&quot;" : '"',
				"&#x27;" : "'"
			},
			unescapeReg : new RegExp("(&amp;|&lt;|&gt;|&quot;|&#x27;)", "g")
		},
		unescape : function(str) {
			var local = this;
			var obj = local._unescape;
			return ("" + str).replace(obj.unescapeReg, function(match) {
				return obj.unescape[match]
			})
		},
		getSohoRoomImage : function(mainimage, prodid, size) {
			if (!_.isEmpty(mainimage)) {
				if (parseInt(size, 10) > 160) {
					size = 160
				}
				return __.getContentImageUrl("/image/shoplogo/"
						+ mainimage.replace(".gif", "_" + size + ".gif"))
			} else {
				if (!_.isEmpty(prodid)) {
					return __.getProductImageUrl("", size, "", prodid)
				} else {
					return __.getErrorImage(160)
				}
			}
		},
		isMileage : function(shop, shop_mileage, daum_mileage,
				daum_base_mileage, isTop) {
			var obj = false;
			shop = shop + "";
			shop_mileage = parseFloat(shop_mileage);
			daum_mileage = parseFloat(daum_mileage);
			daum_base_mileage = parseFloat(daum_base_mileage);
			isTop = isTop + "";
			var shopObj = false;
			if (shop == "11번가" || shop == "11st") {
				shopObj = true
			} else {
				if (shop == "G마켓" || shop == "gmarket") {
					shopObj = true
				} else {
					if (shop == "옥션" || shop == "auction") {
						shopObj = true
					}
				}
			}
			if (shopObj) {
				if (isTop == "Y") {
					return true
				}
				if (shop_mileage > 0) {
					var mileageSum = daum_mileage + daum_base_mileage;
					if (mileageSum > 0) {
						obj = true
					}
				}
			}
			return obj
		},
		isMileagePlusIco : function(shop) {
			var obj = false;
			if (shop == "11번가" || shop == "11st") {
				obj = true
			}
			return obj
		},
		mileageTolltipMassage : function(daum_base_mileage, daum_mileage,
				shop_mileage, cpname) {
			var massage = "";
			shop_mileage = parseFloat(shop_mileage);
			daum_mileage = parseFloat(daum_mileage);
			daum_base_mileage = parseFloat(daum_base_mileage);
			if (daum_mileage <= 0 && shop_mileage == 0) {
				massage = "<em class='emph_mileage'>" + daum_base_mileage
						+ "%</em>"
			} else {
				if (daum_mileage <= 0 && shop_mileage > 0) {
					massage = "<em class='emph_mileage'>"
							+ Number(daum_base_mileage) + "%</em> + " + cpname
							+ " <em class='emph_mileage'>"
							+ Number(shop_mileage) + "%</em>"
				} else {
					if (daum_mileage > 0 && shop_mileage == 0) {
						massage = "<em class='emph_mileage'>"
								+ daum_base_mileage
								+ "%</em> + 추가 <em class='emph_mileage'>"
								+ Number(daum_mileage) + "%</em>"
					} else {
						if (daum_mileage > 0 && shop_mileage > 0) {
							massage = "<em class='emph_mileage'>"
									+ (Number(daum_base_mileage) + Number(daum_mileage))
									+ "%</em> + " + cpname
									+ " <em class='emph_mileage'>"
									+ Number(shop_mileage) + "%</em>"
						} else {
							massage = "MSG null" + daum_base_mileage + "="
									+ daum_mileage + "=" + shop_mileage
						}
					}
				}
			}
			return massage
		}
	};
	window.autoCloseSelectBox = {
		selectBoxlist : [],
		setList : function() {
			this.selectBoxlist = this.selectBoxlist.concat($(".wrap_droplayer")
					.toArray(), $(".wrap_select").toArray())
		},
		addCheckEl : function(el) {
			var ele = null;
			if (typeof (el) === "string") {
				ele = $(el).toArray()
			} else {
				ele = el
			}
			if ($.isArray(ele)) {
				this.selectBoxlist = this.selectBoxlist.concat(ele)
			} else {
				this.selectBoxlist.add(ele)
			}
		},
		whichSelectBox : function(e) {
			var target = e.target;
			var list = $(this.selectBoxlist);
			var el = list.has(target)[0];
			list.each(function(index, item) {
				if (item != el) {
					$(item).removeClass("on")
				}
			})
		}
	};
	window.setClip = function(maintext) {
		if (jQuery.browser.chrome) {
		} else {
			if (window.clipboardData) {
				window.clipboardData.setData("Text", maintext)
			} else {
				if (window.netscape) {
					netscape.security.PrivilegeManager
							.enablePrivilege("UniversalXPConnect");
					var clip = Components.classes["@mozilla.org/widget/clipboard;1"]
							.createInstance(Components.interfaces.nsIClipboard);
					if (!clip) {
						return
					}
					var trans = Components.classes["@mozilla.org/widget/transferable;1"]
							.createInstance(Components.interfaces.nsITransferable);
					if (!trans) {
						return
					}
					trans.addDataFlavor("text/unicode");
					var str = new Object();
					var len = new Object();
					var str = Components.classes["@mozilla.org/supports-string;1"]
							.createInstance(Components.interfaces.nsISupportsString);
					var copytext = maintext;
					str.data = copytext;
					trans.setTransferData("text/unicode", str,
							copytext.length * 2);
					var clipid = Components.interfaces.nsIClipboard;
					if (!clip) {
						return false
					}
					clip.setData(trans, null, clipid.kGlobalClipboard)
				}
			}
		}
	};
	window.rcntprodchecker = "";
	window.updateRecnetProd = function(e) {
		if (!_.isEmpty(window.Shopping.views.rightQuick)) {
			if (window.rcntprodchecker != "") {
				clearTimeout(window.rcntprodchecker)
			}
			window.rcntprodchecker = setTimeout(
					window.Shopping.views.rightQuick.model.fetch, 5000)
		}
	};
	window.commonEventHandler = function() {
		$("body").off("click.autoSelectBox");
		$("body").off("click.syncRecnet");
		autoCloseSelectBox.setList();
		$("body").on("click.autoSelectBox",
				_.bind(autoCloseSelectBox.whichSelectBox, autoCloseSelectBox));
		$("body").on("click.syncRecnet", "a[target]", updateRecnetProd)
	};
	window.setGnbMenu = function(category) {
		$(".gnb_shopping").find("li").removeClass("on");
		if (category) {
			var gCateId = category.substring(0, 3);
			var gnbMap = {
				"101" : "link_gnb2",
				"100" : "link_gnb3",
				"104" : "link_gnb4",
				"102" : "link_gnb5",
				"103" : "link_gnb6"
			};
			var gnbMenuClass = gnbMap[gCateId] || "";
			if (gnbMenuClass != "") {
				$(".gnb_shopping").find("." + gnbMenuClass).parent().addClass(
						"on")
			} else {
				$(".gnb_shopping").find("li").removeClass("on")
			}
		}
	};
	window.mobileSetFix = function(options) {
		this.init(options);
		return {
			reset : function() {
				this.resetFix()
			}.bind(this)
		}
	};
	mobileSetFix.prototype = {
		win : $(window),
		init : function(options) {
			this.options = _.extend(options, {
				position : "fixed"
			});
			this.win.on("popstate.mSetFix", _.bind(this.resetFix, this));
			this.win.on("hashchange.mSetFix", _.bind(this.resetFix, this));
			this.setting();
			this.setHandler()
		},
		resetFix : function() {
			this.unsetHandler();
			this.setting();
			this.setHandler()
		},
		setting : function() {
			this.objSetting = false;
			if (this.options.position == "fixed") {
				this.getFixedLayerObj().empty()
			} else {
			}
		},
		setHandler : function() {
			if (this.options.position == "fixed") {
				this.win.on("scroll.mSetFix", _.bind(
						this.changeFixedLayerPosition, this))
			} else {
				this.win
						.on("scroll.mSetFix", _.bind(this.changePosition, this))
			}
		},
		unsetHandler : function() {
			$(window).off("scroll.mSetFix")
		},
		getFixObj : function() {
			return $(".__fixed_obj")
		},
		getFixedLayerObj : function() {
			return $("#fixedLayer__")
		},
		changeFixedLayerPosition : function() {
			var scroll = 0;
			scroll = this.win.scrollTop();
			if (!this.objSetting) {
				this.setFixLayerObjData()
			}
			var fixedLayer = this.getFixedLayerObj();
			var fixData = fixedLayer.data("fix");
			if (fixData.min < scroll && fixData.min < fixData.max
					&& scroll <= fixData.max) {
				fixedLayer.css({
					display : "block",
					top : fixData.fixTop,
					left : fixData.fixLeft,
					"z-index" : 99
				})
			} else {
				if (fixData.min >= scroll || fixData.min >= fixData.max) {
					fixedLayer.removeAttr("style");
					fixedLayer.attr("style", fixData.originStyle)
				} else {
					if (fixData.max <= scroll && fixData.min <= scroll) {
						var endPosition = fixData.originPosition;
						if (endPosition != "absolute"
								&& endPosition != "relative") {
							endPosition = "absolute"
						}
						fixedLayer.css({
							position : endPosition,
							top : fixData.maxTop,
							left : fixData.originLeft,
							marginLeft : fixData.originMargin
						})
					}
				}
			}
		},
		changePosition : function() {
			var scroll = 0;
			scroll = $("body").scrollTop();
			if (!this.objSetting) {
				this.setFixObjData()
			}
			_
					.each(
							this.getFixObj(),
							function(t, i) {
								var fixData = $(t).data("fix");
								if (fixData.already) {
									if (fixData.min < scroll
											&& fixData.min < fixData.max
											&& scroll <= fixData.max) {
										$(t)
												.css(
														{
															position : "absolute",
															top : fixData.originTop
																	+ scroll
																	- fixData.originParents,
															left : fixData.fixLeft,
															"z-index" : 99
														})
									} else {
										if (fixData.min >= scroll
												|| fixData.min >= fixData.max) {
											$(t).removeAttr("style");
											$(t).attr("style",
													fixData.originStyle)
										} else {
											if (fixData.max <= scroll
													&& fixData.min <= scroll) {
												var endPosition = fixData.originPosition;
												if (endPosition != "absolute"
														&& endPosition != "relative") {
													endPosition = "absolute"
												}
												$(t)
														.css(
																{
																	position : endPosition,
																	top : fixData.maxTop,
																	left : fixData.originLeft,
																	marginLeft : fixData.originMargin
																})
											}
										}
									}
								}
							}.bind(this))
		},
		setFixLayerObjData : function() {
			var fixData = {};
			var fixedLayer = this.getFixedLayerObj();
			var objFixData = fixedLayer.data("fix");
			_.extend(fixData, objFixData);
			fixData.originTop = fixData.originTop
					|| isNaN(parseInt(fixedLayer.css("top"), 10)) ? 0
					: parseInt(fixedLayer.css("top"), 10);
			fixData.originLeft = fixData.originLeft
					|| fixedLayer.css("left") == "auto" ? fixedLayer.position().left
					: fixedLayer.css("left");
			fixData.originPosition = fixData.originPosition
					|| fixedLayer.css("position");
			fixData.originMargin = fixData.originMargin
					|| fixedLayer.css("margin-left") || 0;
			fixData.originStyle = fixData.originStyle
					|| fixedLayer.attr("style") || " ";
			fixData.min = fixData.min || this.options.min || 0;
			fixData.max = fixData.max || this.options.max || 999999;
			fixData.fixTop = fixData.fixTop || 0;
			fixData.fixLeft = fixData.fixLeft || 0;
			fixData.maxTop = fixData.maxTop || fixData.max;
			fixData.already = true;
			fixedLayer.data("fix", fixData);
			this.objSetting = true
		},
		setFixObjData : function() {
			_.each(this.getFixObj(), function(t, i) {
				var fixData = {};
				var objFixData = $(t).data("fix");
				_.extend(fixData, objFixData);
				var offset = $(t).offset();
				fixData.originTop = fixData.originTop
						|| isNaN(parseInt($(t).css("top"), 10)) ? 0 : parseInt(
						$(t).css("top"), 10);
				fixData.originLeft = fixData.originLeft
						|| (t).css("left") == "auto" ? $(t).position().left
						: $(t).css("left");
				fixData.originPosition = fixData.originPosition
						|| $(t).css("position");
				fixData.originMargin = fixData.originMargin
						|| $(t).css("margin-left");
				fixData.originStyle = fixData.originStyle || $(t).attr("style")
						|| " ";
				fixData.originParents = $(t).parents().map(function() {
					if ($(this).css("position") == "relative") {
						return $(this).offset().top
					}
				}).get(0) || 0;
				fixData.min = fixData.min || offset.top;
				fixData.max = fixData.max || 999999;
				fixData.fixTop = fixData.fixTop || 0;
				fixData.fixLeft = fixData.fixLeft || 0;
				fixData.maxTop = fixData.maxTop || fixData.max;
				fixData.already = true;
				$(t).data("fix", fixData)
			});
			this.objSetting = true
		}
	};
	window.checkNewSection = function(obj) {
		var icon = '<span class="ico_key icon_newsection">새로운 서비스</span>';
		if (defaultSetting && _.size(defaultSetting.newSectionList) > 0) {
			var newSectionList = _.filter(obj, function(item) {
				var blnNewSection = false;
				_.each(defaultSetting.newSectionList, function(section) {
					if ($(item).attr("href").indexOf(section) >= 0) {
						blnNewSection = true
					}
				});
				return blnNewSection
			});
			_.each(newSectionList, function(item) {
				$(item).find(".icon_newsection").detach();
				$(item).append(icon)
			})
		}
	}
})(jQuery);
(function($) {
	var SHOP_PROTOTYPE = function() {
		this.ready = false;
		this.init = function(param) {
			this.nImg = (!this.nImg) ? new Image(0, 0) : this.nImg;
			jQuery.extend(this.param, param);
			this.ready = true
		};
		this.send = function(param) {
			s_console.log("send");
			if (!this.ready) {
				this.init()
			}
			var lkj = this;
			_.each(param.split(","), function(item) {
				item = $.trim(item);
				lkj.setParam(item.substr(0, item.indexOf("=")), item
						.substr(item.indexOf("=") + 1))
			});
			this.setParam("cco", $.now());
			this.nImg.src = this.nURL + this.setUrlQuery()
		};
		this.getParam = function(key) {
			return (_.isUndefined(this.param[key])) ? "" : this.param[key] + ""
		};
		this.setParam = function(key, value) {
			s_console.log("setParam", key, value);
			this.param[key] = value
		}
	};
	var SHOP_CC = function() {
		this.param = {
			t : "",
			g : "",
			a : "",
			tp : 1,
			ad : "",
			d : "",
			o : "",
			c : "",
			ps : "",
			pc : "",
			pp : "",
			sc : "",
			sq : "",
			sa : "",
			sb : "",
			se : "",
			st : "",
			spc : "",
			spqid : "",
			page : 1,
			ext : "",
			v : "D"
		};
		this.nURL = "http://shopping.tiara.daum.net/tiara.front";
		this.setHandler = function(parent) {
			if (!this.ready) {
				this.init()
			}
			s_console.log("setHandler");
			parent = (_.isUndefined(parent)) ? document : parent;
			var lkj = this;
			_.each($(parent).find("[data-cc]"), function(item, i) {
				$(item).off("click", lkj.clickEvent);
				$(item).on("click", lkj, lkj.clickEvent)
			})
		};
		this.clickEvent = function(e) {
			s_console.log("clickEvent", e);
			var lkj = e.data;
			var href = $(e.currentTarget).attr("href");
			if ($(e.currentTarget).get(0).tagName == "A"
					&& $(e.currentTarget).attr("target") != "_blank"
					&& __.isMobile()
					&& (href.indexOf("/mini/#!/detail/") >= 0
							|| href.indexOf("/mini/productdetail.daum") >= 0
							|| href.indexOf("http://") >= 0 || href
							.indexOf("/mini/prodlist.daum") >= 0)) {
				if (!e.isDefaultPrevented()) {
					e.preventDefault();
					$(lkj.nImg).one("load", function() {
						location.href = href
					})
				}
			}
			lkj.setParam("ps", "");
			lkj.setParam("pc", "");
			lkj.setParam("pp", "");
			lkj.setParam("ext", "");
			lkj.send(this.getAttribute("data-cc"))
		};
		this.setUrlQuery = function() {
			var hash = document.location.hash.split("/");
			var urlQuery = "?v=" + this.getParam("v");
			urlQuery = urlQuery + "&t=" + this.getParam("t");
			urlQuery = urlQuery + "&g=" + this.getParam("g");
			urlQuery = urlQuery + "&a=" + this.getParam("a");
			urlQuery = urlQuery + "&d=" + this.getParam("d");
			urlQuery = urlQuery + "&o=" + this.getParam("o");
			urlQuery = urlQuery + "&c=" + this.getParam("c");
			urlQuery = urlQuery + "&tp=" + this.getParam("tp");
			urlQuery = urlQuery + "&spqid=" + this.getParam("spqid");
			urlQuery = urlQuery + "&ad=" + this.getParam("ad");
			urlQuery = urlQuery + "&ps=" + this.getParam("ps");
			urlQuery = urlQuery + "&pc=" + this.getParam("pc");
			urlQuery = urlQuery + "&pp=" + this.getParam("pp");
			urlQuery = urlQuery + "&sc="
					+ this.getParam("sc").replace(/,/g, "");
			urlQuery = urlQuery + "&sq=" + this.getParam("sq");
			urlQuery = urlQuery + "&sa=" + this.getParam("sa");
			urlQuery = urlQuery + "&sb=" + this.getParam("sb");
			urlQuery = urlQuery + "&se=" + this.getParam("se");
			urlQuery = urlQuery + "&st=" + this.getParam("st");
			urlQuery = urlQuery + "&e=" + this.getParam("e");
			urlQuery = urlQuery + "&spc=" + this.getParam("spc");
			urlQuery = urlQuery + "&page=" + this.getParam("page");
			urlQuery = urlQuery
					+ "&ext="
					+ this.getParam("ext").replace(/=/g, "|:|").replace(/&/g,
							"]^[");
			urlQuery = urlQuery + "&hashtag="
					+ encodeURIComponent(hash[hash.length - 1] || "");
			urlQuery = urlQuery + "&_=" + $.now();
			return urlQuery
		}
	};
	SHOP_CC.prototype = new SHOP_PROTOTYPE();
	window.SHOP_CC = SHOP_CC;
	var SHOP_TQ = function() {
		this.param = {
			spqid : "",
			devid : "",
			sflag : "",
			saq : "",
			sq : "",
			sa : "",
			page : "",
			sc : "",
			preferer : ""
		};
		this.nURL = "http://shopping.tiara.daum.net/tiara.query";
		this.setUrlQuery = function() {
			var urlQuery = "?spqid=" + this.getParam("spqid");
			urlQuery = urlQuery + "&devid=" + this.getParam("devid");
			urlQuery = urlQuery + "&sflag=" + this.getParam("sflag");
			urlQuery = urlQuery + "&saq=" + this.getParam("saq");
			urlQuery = urlQuery + "&sq=" + this.getParam("sq");
			urlQuery = urlQuery + "&sa=" + this.getParam("sa");
			urlQuery = urlQuery + "&page=" + this.getParam("page");
			urlQuery = urlQuery + "&sc=" + this.getParam("sc");
			urlQuery = urlQuery + "&preferer=" + this.getParam("preferer");
			urlQuery = urlQuery + "&_=" + $.now();
			return urlQuery
		}
	};
	SHOP_TQ.prototype = new SHOP_PROTOTYPE();
	window.SHOP_TQ = SHOP_TQ
}).call(this, jQuery);
(function($) {
	Backbone.ShoppingModel = Backbone.Model
			.extend({
				sendTiara : function(url, title) {
					try {
						if (typeof _tiq !== "undefined") {
							_tiq
									.push([
											"__pageView",
											{
												url : url,
												title : title,
												referer : (Backbone.history.prevMainHash ? window.location.href
														: document.referrer)
											} ]);
							s_console.debug("sendTiara", url, title)
						}
					} catch (e) {
						s_console.debug("sendTiara ERROR", e)
					}
				},
				sendKoreanClick : function(url, title) {
					url = encodeURIComponent(url);
					title = encodeURIComponent(title);
					document.getElementById("koreanClick").contentWindow.location
							.replace("/statics/html/empty.html?url=" + url
									+ "&title=" + title + "&date="
									+ (new Date).getTime())
				},
				sendPageView : function(options) {
					var searchQuery = (options && options.data && options.data.q) ? "?q="
							+ options.data.q
							: "";
					if (this.tiara) {
						this.sendTiara(this.tiara.url + searchQuery,
								this.tiara.title);
						this.sendKoreanClick(this.tiara.url + searchQuery,
								this.tiara.title)
					}
					if (window.roosevelt_params && options && options.daTag) {
						this.sendDaTag(options.daTag)
					}
				},
				sendDaTag : function(param, value) {
					if (_.isObject(param)) {
						_.extend(roosevelt_params, param)
					} else {
						if (_.has(roosevelt_params, param)) {
							roosevelt_params[param] = value
						}
					}
					if (window.Roosevelt) {
						Roosevelt.run()
					} else {
						$.ajax({
							url : "http://adimg.daumcdn.net/rt/roosevelt.js",
							dataType : "script",
							cache : true
						})
					}
				},
				fetch : function(options) {
					options = options ? _.clone(options) : {};
					options = _.defaults(options, {
						sendtiara : true
					});
					options.cache = false;
					_.extend(this.tiara, options.tiara);
					if (this.tiara && options.sendtiara) {
						this.sendPageView(options)
					}
					var apiName = "";
					var jsonData = false;
					var lkj = this;
					_.each(Shopping.apis, function(item, key) {
						if (lkj.url == item) {
							apiName = key
						}
					});
					if (options.uselocal === true) {
						jsonData = localJson.getJson(apiName);
						if (jsonData) {
							this.set(jsonData);
							if (options.remake) {
								s_console.log("trigger remake");
								this.trigger("remake")
							}
							return true
						}
					}
					if (options.useloading
							&& !$("#daumContent").is(":has(.loading)")) {
						$("#loading").show()
					}
					if (ASYNC === "Y") {
						options.async = false
					}
					var originSuccess = options.success;
					options.success = _.bind(function(model, resp) {
						if (originSuccess) {
							originSuccess(model, resp)
						}
						if (options.remake) {
							s_console.log("trigger remake");
							this.trigger("remake", model, resp)
						}
						if (!jsonData && options.uselocal === true) {
							localJson.setJson(apiName, JSON.stringify(model
									.toJSON()))
						}
					}, this);
					if (_.indexOf(Shopping.mainApi, apiName) > -1) {
						if (options.statusCode === undefined) {
							options.statusCode = {}
						}
						options.statusCode = _.extend(options.statusCode,
								BasicStatusCode)
					}
					return Backbone.Model.prototype.fetch.call(this, options)
				},
				parse : function(resp, xhr) {
					$("#loading").hide();
					if (resp.code != 200) {
						if (CustomStatusCode[resp.code] !== undefined) {
							CustomStatusCode[resp.code](resp)
						} else {
							s_console.log("Error Code : " + resp.code)
						}
					}
					return resp
				},
				resetDefault : function(options) {
					this.attributes = {};
					this.set(this.defaults, options)
				}
			})
})(jQuery);
(function($) {
	Backbone.ShoppingCollection = Backbone.Collection.extend({
		fetch : function(options) {
			$("#blinder").show();
			options = options ? _.clone(options) : {};
			options.cache = false;
			var apiName = "";
			var jsonData = false;
			var lkj = this;
			_.each(Shopping.apis, function(item, key) {
				if (lkj.url == item) {
					apiName = key
				}
			});
			if (options.uselocal === true) {
				jsonData = localJson.getJson(apiName);
				if (jsonData) {
					this.set(jsonData);
					if (options.remake) {
						s_console.log("trigger remake");
						this.trigger("remake")
					}
					$("#blinder").hide();
					return true
				}
			}
			var originSuccess = options.success;
			options.success = _.bind(function(model, resp) {
				if (originSuccess) {
					originSuccess(model, resp)
				}
				if (options.remake) {
					s_console.log("trigger remake");
					this.trigger("remake")
				}
				if (!jsonData && options.uselocal === true) {
					localJson.setJson(apiName, JSON.stringify(model.toJSON()))
				}
				$("#blinder").hide()
			}, this);
			if (_.indexOf(Shopping.mainApi, apiName) > -1) {
				if (options.statusCode === undefined) {
					options.statusCode = {}
				}
				options.statusCode = _.extend(options.statusCode,
						BasicStatusCode)
			}
			Backbone.Collection.prototype.fetch.call(this, options)
		},
		parse : function(resp, xhr) {
			var resultName = this.url.match(/[\w]*(?=\.)/g)[0];
			var result = null;
			if (resp.code == 200) {
				result = resp[resultName]
			} else {
				if (CustomStatusCode[resp.code] !== undefined) {
					CustomStatusCode[resp.code]()
				} else {
					s_console.log("Error Code : " + resp.code)
				}
			}
			return result
		},
		model : Backbone.ShoppingModel
	})
})(jQuery);
(function($) {
	Backbone.ShoppingView = Backbone.View
			.extend({
				constructor : function(options) {
					this.configure(options || {});
					Backbone.View.prototype.constructor.apply(this, arguments)
				},
				configure : function(options) {
					if (this.options) {
						options = _.extend({}, _.result(this, "options"),
								options)
					}
					this.options = options;
					if (options.rendertrigger) {
						var _this = this;
						_.bindAll(_this, "render", "afterRender");
						this.render = _.wrap(this.render, function(render) {
							render();
							_this.setClickCode();
							if (M_SHOPHOW.GNB) {
								M_SHOPHOW.GNB.checkZZim()
							}
							_this.afterRender();
							return _this
						})
					}
				},
				afterRender : function() {
					this.trigger("render:after", this)
				},
				template : {},
				childView : {},
				SHOP_CC : null,
				SHOP_TQ : null,
				error : function(e) {
					if (SERVERNAME == "development") {
						console.log(e.stack)
					} else {
						Tico.getInstance().send(e, "ViewError", {
							TYPE : Tico.CATCH_ERROR,
							url : document.location.href
						})
					}
				},
				setTemplate : function(source) {
					var htmlStr = TEMPLATE[source.substr(1)]
							|| $(source).html();
					if (this.options.lazyload === true && !__.isMobile()) {
						htmlStr = this.preLazyload(htmlStr)
					}
					this.template = _.template(htmlStr)
				},
				getTemplate : function(data) {
					s_console.debug("getTemplate", this.el);
					return $.trim(this.template(data))
				},
				childTemplate : {},
				setChildTemplate : function(target, source) {
					if (!this.childTemplate) {
						this.childTemplate = {}
					}
					if (_.isEmpty(source)) {
						source = target
					}
					if (!this.childTemplate[target]) {
						var htmlStr = TEMPLATE[source.substr(1)]
								|| $(source).html();
						this.childTemplate[target] = _.template(htmlStr)
					}
				},
				getChildTemplate : function(target, data) {
					if (!this.childTemplate[target]) {
						this.setChildTemplate(target)
					}
					return $.trim(this.childTemplate[target](data))
				},
				setClickCode : function(params, opt) {
					var option = _.isBoolean(opt) ? opt : true;
					if (typeof SHOP_CC != "undefined") {
						if (this.SHOP_CC === null) {
							this.SHOP_CC = new SHOP_CC()
						}
						this.SHOP_CC.init(params);
						if (option) {
							this.SHOP_CC.setHandler(this.el)
						}
					}
				},
				sendClickCode : function(params) {
					if (typeof SHOP_CC != "undefined") {
						if (this.SHOP_CC === null) {
							this.SHOP_CC = new SHOP_CC()
						}
						this.SHOP_CC.send(params)
					}
				},
				sendTongQuery : function(params) {
					if (typeof SHOP_TQ != "undefined") {
						if (this.SHOP_TQ === null) {
							this.SHOP_TQ = new SHOP_TQ();
							this.SHOP_TQ.init()
						}
						this.SHOP_TQ.send(params)
					}
				},
				setDocumentTitle : function(title) {
					document.title = (title)
				},
				lazyload : function(e) {
					var option = this.options.lazyOption || {};
					this.$el.find("img").lazyload(option)
				},
				preLazyload : function(htmlstr) {
					var originRender = _.bind(this.render, this);
					this.render = function(opt) {
						originRender(opt);
						try {
							this.lazyload();
							return this
						} catch (e) {
							this.error(e)
						}
					};
					var loadurl = (this.options.lazyOption && this.options.lazyOption.loadurl) ? this.options.lazyOption.loadurl
							: "http://i1.daumcdn.net/imgsrc.search/shopping/img/whitedot.gif";
					return htmlstr.replace(/\ssrc=/g, ' src="' + loadurl
							+ '" data-original=')
				},
				setFacebookShare : function(obj) {
					_.each(_.keys(obj), function(t, i) {
						if ($("head").find('meta[property="og:' + t + '"]')
								.size() == 0) {
							$("head").append(
									'<meta property="og:' + t + '" content="'
											+ obj[t] + '" />')
						}
					})
				},
				bulidParam : function(param, value) {
					var option = _.clone(this.params), s = [], add = function(
							value, key) {
						value = value + "";
						!_.isEmpty(value) ? (s[s.length] = encodeURIComponent(key)
								+ ":" + encodeURIComponent(value))
								: ""
					};
					if (!_.isEmpty(param)) {
						if (_.isObject(param)) {
							option = _.extend(option, param)
						} else {
							option[param] = value
						}
					}
					_.each(option, add);
					return s.join("&").replace(/%20/g, "+")
				},
				getMoveHash : function(param, value) {
					var args = this.bulidParam(param, value);
					return this.rootUrl + args
				},
				setNavigation : function(param, value, option) {
					if (_.isObject(param)) {
						option = value
					}
					var naviOption = _.defaults(option || {}, {
						trigger : true
					});
					Backbone.history.navigate(this.getMoveHash(param, value),
							naviOption)
				},
				rootUrl : "",
				params : ""
			})
})(jQuery);
(function($) {
	Backbone.ShoppingRouter = Backbone.Router.extend({});
	Backbone.History.prototype.originCheckURL = Backbone.History.prototype.checkUrl;
	Backbone.History.prototype.checkUrl = function(e) {
		this.mainHash = this.getFragment().match(/^\S+?(?=\/)/)
				|| [ this.getFragment() ];
		this.prevMainHash = this.fragment.match(/^\S+?(?=\/)/)
				|| [ this.fragment ];
		if (this.mainHash[0] !== this.prevMainHash[0]) {
			this.trigger("mainchange")
		}
		this.originCheckURL(e)
	}
})(jQuery);
coco.modules.shoppingSuggest = (function() {
	var options = {
		formEl : "daumInnerSearchForm",
		layerEl : "innerShoppingSearch",
		suggestNumber : 5,
		serviceProfile : "",
		enableLatestKeyword : false,
		searchURL : "http://" + document.location.host + "/mini/search.daum",
		endpoint : {
			url : "http://sug.api.search.daum.net/shop_top_chsuggest",
			query : "mod=json&code=utf_in_out"
		}
	};
	function setOptions(suggestOptions) {
		var op = {};
		for ( var option in options) {
			if (options.hasOwnProperty(option)) {
				op[option] = suggestOptions[option] || options[option]
			}
		}
		return op
	}
	var ExtendedInputViewController = daum.suggest.GenericInputViewController
			.extend({
				init : function(el, layer, sandbox) {
					this._super(el, layer, sandbox);
					if (coco.ua.browser.android) {
						var placeholder = this.placeholder = document
								.createElement("span");
						placeholder.id = "placeholder_" + layer.id;
						daumtools.classList.add(placeholder,
								"placeholder_suggest");
						placeholder.style.cssText = "float:left;position:absolute;top:6px;left:12px;font-size:14px;color:#808080;letter-spacing:-1px";
						placeholder.innerHTML = this.el
								.getAttribute("placeholder");
						this.el.setAttribute("placeholder", "");
						this.el.parentNode.appendChild(placeholder);
						if (!this.isEmpty()) {
							this._hidePlaceholder()
						}
					}
				},
				_render : function() {
					if (this.isEmpty()) {
						this._hideResetButton()
					} else {
						this._showResetButton()
					}
					this._turnOffNativeAutoComplete()
				},
				_toggleResetButton : function() {
					if (this.isEmpty()) {
						this._hideResetButton();
						this._showPlaceholder()
					} else {
						this._showResetButton();
						this._hidePlaceholder()
					}
				},
				_showPlaceholder : function() {
					if (this.placeholder) {
						if (daumtools.$("placeholder")) {
							daumtools.classList.remove(daumtools
									.$("placeholder"), "hide")
						}
						var placeholderList = daumtools
								.$$(".placeholder_suggest");
						for (var i = 0; i < placeholderList.length; i++) {
							daumtools.classList.remove(placeholderList[i],
									"hide")
						}
					}
				},
				_hidePlaceholder : function() {
					if (this.placeholder) {
						if (daumtools.$("placeholder")) {
							daumtools.classList.add(daumtools.$("placeholder"),
									"hide")
						}
						var placeholderList = daumtools
								.$$(".placeholder_suggest");
						for (var i = 0; i < placeholderList.length; i++) {
							daumtools.classList.add(placeholderList[i], "hide")
						}
					}
				}
			});
	daum.suggest.Suggest = daum.suggest.Suggest.extend({
		submit : function(e) {
			daumtools.event.preventDefault(e);
			var queryEl = this.formEl.q;
			var query = daumtools.trim(queryEl.value);
			this.sandbox.emit("suggest:hide");
			if (query != "") {
				queryEl.value = query;
				queryEl.blur();
				if (Shopping.routes.mobileSearch) {
					Shopping.routes.mobileSearch.navigate("!/search/"
							+ encodeURIComponent(query) + "/", {
						trigger : true
					})
				} else {
					document.location.href = "/mini/#!/search/"
							+ encodeURIComponent(query) + "/"
				}
				return false
			} else {
				alert("검색어를 입력해주세요.");
				queryEl.value = "";
				return false
			}
		},
		_bindEvent : function() {
			this._super();
			this.formEl.onsubmit = this.submit.bind(this)
		}
	});
	daum.suggest.SuggestItemView = daum.suggest.SuggestItemView.extend({
		init : function(query, item, index) {
			this.query = query;
			item.keyword = item.keyword.replace(/\|.+/, "");
			this.item = item;
			this.index = index;
			this.isUrlPatternMatch = this
					._checkUrlPatternMatch(this.item.keyword)
		}
	});
	daum.suggest.SuggestListView = daum.suggest.SuggestListView
			.extend({
				show : function() {
					this._super();
					if (window.gargoyle) {
						$(this.el).find("a").click(
								function() {
									gargoyle.click({}, this, {
										tp : "Q",
										qt : "S",
										q : encodeURIComponent($(this).parent()
												.data("query"))
									})
								})
					}
				},
				_renderButton : function() {
					return (this.options.formEl == "daumTotalSearchForm") ? ""
							: '<div class="foot_suggest"><button type="button" class="btn_close" id="btn_close_inner_suggest"><span class="img_g ico_close"></span>닫기</button></div>'
				},
				_bindEvent : function() {
					this._super();
					var self = this;
					daumtools.event.delegate(this.el, ".btn_close", "click",
							function() {
								self.hide()
							})
				}
			});
	return {
		init : function(suggestOptions) {
			suggestOptions = suggestOptions || {};
			this.option = setOptions(suggestOptions)
		},
		initAfterOnload : function() {
			this.innerSuggest = this.add(this.option)
		},
		checkInputValue : function() {
			if (this.innerSuggest) {
				this.innerSuggest.inputView._toggleResetButton()
			}
		},
		add : function(suggestOptions) {
			suggestOptions.ExtendedInputViewController = ExtendedInputViewController;
			var innerSuggest = "";
			if (daumtools.$(suggestOptions.layerEl)) {
				innerSuggest = new daum.suggest.Suggest(daumtools
						.$(suggestOptions.layerEl), suggestOptions);
				if (suggestOptions.enableLatestKeyword === false) {
					innerSuggest.suggestStorage.disable()
				}
			} else {
				innerSuggest = null
			}
			return innerSuggest
		},
		reset : function() {
			$("#innerSugeestLayer").children().detach();
			setTimeout(function() {
				this.innerSuggest.init(daumtools.$(this.option.layerEl),
						this.option)
			}.bind(this), 500)
		}
	}
})();
coco.moduleInitAfterOnload = function() {
	coco._forEachModule(function(name, module) {
		if (module.initAfterOnload) {
			module.initAfterOnload(coco.configure[name], self)
		}
		if (module.version) {
			coco.modules.version[name] = module.version
		}
	})
};
(function() {
	var cssText = "\n/* 쇼핑 실시간이슈 */\n.d_isu {height:39px}.d_isu_open {height:442px}.d_isu_open .slide_area {display:block;overflow:hidden;height:366px}\n.d_isu .ico_check {display:block;overflow:hidden;font-size:0;line-height:0;background:url(http://m1.daumcdn.net/imgsrc.search/shopping/img/mobile/320/ico_check.png) no-repeat 0 0;text-indent:-9999px}\n@media\nonly screen and (-webkit-min-device-pixel-ratio: 1.5),\nonly screen and (min-device-pixel-ratio: 1.5) {\n.d_isu .ico_check {background-image:url(http://m1.daumcdn.net/imgsrc.search/shopping/img/mobile/480/ico_check.png);-webkit-background-size:13px 19px;background-size:13px 19px} \n}\n@media\nonly screen and (-webkit-min-device-pixel-ratio: 2),\nonly screen and (min-device-pixel-ratio: 2) {\n.d_isu .ico_check {background-image:url(http://m1.daumcdn.net/imgsrc.search/shopping/img/mobile/640/ico_check.png);-webkit-background-size:13px 19px;background-size:13px 19px} \n}\n.d_isu .link_tab .no_tab_view {position:absolute;text-indent:-9999px;left:-9999px}\n.d_isu .tab_rank {overflow:hidden;width:100%;border-bottom:1px solid #f6f6f6} \n.d_isu .tab_rank li {float:left} \n.d_isu .tab_rank .link_tab {display:block;padding:10px 20px 9px 11px;font-size:13px;line-height:15px;color:#888;letter-spacing:-1px} \n.d_isu .tab_rank .on .link_tab {color:#1a1a1c} \n.d_isu .tab_rank .ico_check {float:left;width:13px;height:9px;margin:3px 2px 0 0} \n.d_isu .tab_rank .on .ico_check {background-position:0 -10px} \n", styleEl = document
			.createElement("style");
	document.getElementsByTagName("head")[0].appendChild(styleEl);
	if (styleEl.styleSheet) {
		if (!styleEl.styleSheet.disabled) {
			styleEl.styleSheet.cssText = cssText
		}
	} else {
		try {
			styleEl.innerHTML = cssText
		} catch (e) {
			styleEl.innerText = cssText
		}
	}
}());
(function() {
	hottrends.ShoppingMain = hottrends.Main.extend({
		setActiveCollectionByIndex : function(index) {
			this.tabView.setActiveByIndex(index);
			this.collectionsView.setActiveByIndex(index);
			this.navCtrlView.setActiveByIndex(index);
			this.frameView.setActiveCollection(this.getActiveCollection());
			this.resetSubTab()
		},
		resetSubTab : function() {
			var target = daumtools.$$(".link_tab_M", this.el);
			for (var i = 0; i < target.length; i++) {
				hottrends.changeSubTab(target[i], window.thisSex)
			}
		}
	});
	hottrends.changeSubTab = function(el, value) {
		var femaleTab = daumtools.$$(".link_tab_F", el.parentNode.parentNode)[0], maleTab = daumtools
				.$$(".link_tab_M", el.parentNode.parentNode)[0], femaleContents = daumtools
				.$$(".female_list", el.parentNode.parentNode.parentNode)[0], maleContents = daumtools
				.$$(".male_list", el.parentNode.parentNode.parentNode)[0];
		if (value == "F") {
			daumtools.classList.remove(femaleTab.parentNode, "on");
			daumtools.classList.add(femaleTab.parentNode, "on");
			daumtools.classList.remove(maleTab.parentNode, "on");
			femaleContents.style.display = "block";
			maleContents.style.display = "none"
		} else {
			daumtools.classList.remove(maleTab.parentNode, "on");
			daumtools.classList.add(maleTab.parentNode, "on");
			daumtools.classList.remove(femaleTab.parentNode, "on");
			maleContents.style.display = "block";
			femaleContents.style.display = "none"
		}
	};
	hottrends.TabView = Class
			.extend({
				init : function(baseEl, collections) {
					this.el = daumtools.$$(".tab_issue", baseEl)[0];
					this.collections = collections;
					this.index = 0;
					this._render();
					this._bindEvents()
				},
				onClick : function() {
				},
				setActiveByIndex : function(index) {
					if (index !== this.index) {
						this.index = index;
						this._render();
						this._triggerReflow()
					}
				},
				_triggerReflow : function() {
					return this.el.offsetHeight
				},
				_render : function() {
					var tabEl = this.el, buffer = [], className, minCnt, maxCnt;
					maxCnt = (this.collections.length >= 3) ? 3
							: this.collections.length;
					minCnt = (this.index <= 1) ? 0
							: (this.index < (this.collections.length - 1) ? this.index - 1
									: maxCnt);
					for (var i = 0; i < maxCnt; i += 1) {
						if (i === 0) {
							className = "fst"
						} else {
							if (i === (maxCnt - 1)) {
								className = "lst"
							} else {
								className = ""
							}
						}
						if (this.index == (i + minCnt)) {
							className += " on"
						}
						buffer.push('<li class="' + className + '">');
						buffer
								.push('<a href="#none" class="link_tab" data-index="'
										+ (i + minCnt)
										+ '">'
										+ this.collections[i + minCnt].name);
						if (this.collections[i + minCnt].isNew) {
							buffer
									.push('<span class="img_g ico_new" data-index="'
											+ (i + minCnt) + '">(신규)</span>')
						}
						buffer.push("</a>");
						buffer.push("</li>")
					}
					tabEl.innerHTML = buffer.join("");
					daumtools.classList.add(tabEl, "tab_issue" + maxCnt)
				},
				_bindEvents : function() {
					var self = this;
					daumtools.event
							.on(
									this.el,
									"click",
									function(e) {
										var targetEl = e.target || e.srcElement, index = parseInt(
												targetEl
														.getAttribute("data-index"),
												10);
										self.setActiveByIndex(index);
										self.onClick(index);
										daumtools.event.preventDefault(e)
									})
				}
			});
	hottrends.setClickCode = (function() {
		function cClickCode(t, g, a, d, o, c, ps, pc, pp, sc, sq, sa, e, ext,
				tp, ad, spqid, sb, se, st, ver, page) {
			var urlQuery = "";
			var nURL = "http://shopping.tiara.daum.net/tiara.front";
			var nImg = new Image();
			var cco = new Date().getTime();
			var txtad = (typeof ad == "undefined") ? "" : ad;
			var txtspqid = (typeof spqid == "undefined") ? "" : spqid;
			var txtsb = (typeof sb == "undefined") ? "" : sb;
			var txtse = (typeof se == "undefined") ? "" : se;
			var txtst = (typeof st == "undefined") ? "" : st;
			var ipage = (typeof page == "undefined") ? "1" : page;
			urlQuery = urlQuery + "&t=" + t;
			urlQuery = urlQuery + "&tp=" + tp;
			urlQuery = urlQuery + "&ad=" + txtad;
			urlQuery = urlQuery + "&spqid=" + txtspqid;
			urlQuery = urlQuery + "&g=" + g;
			urlQuery = urlQuery + "&a=" + a;
			urlQuery = urlQuery + "&d=" + d;
			urlQuery = urlQuery + "&o=" + o;
			urlQuery = urlQuery + "&c=" + c;
			urlQuery = urlQuery + "&ps=" + ps;
			urlQuery = urlQuery + "&pc=" + pc;
			urlQuery = urlQuery + "&pp=" + pp;
			urlQuery = urlQuery + "&sc=" + sc.replace(/,/g, "");
			urlQuery = urlQuery + "&sq=" + sq;
			urlQuery = urlQuery + "&sa=" + sa;
			urlQuery = urlQuery + "&sb=" + txtsb;
			urlQuery = urlQuery + "&se=" + txtse;
			urlQuery = urlQuery + "&st=" + txtst;
			urlQuery = urlQuery + "&e=" + e;
			urlQuery = urlQuery + "&spc=" + spc;
			urlQuery = urlQuery + "&page=" + ipage;
			urlQuery = urlQuery + "&ext="
					+ ext.replace(/=/g, "|:|").replace(/&/g, "]^[");
			nImg.src = nURL + "?v=" + ver + urlQuery + "&cco=" + (++cco);
			return true
		}
		var hot_SHOP_CC = null;
		if (typeof SHOP_CC != "undefined") {
			hot_SHOP_CC = new SHOP_CC()
		} else {
			hot_SHOP_CC = {
				data : {
					t : "",
					g : "",
					a : "",
					tp : 1,
					ad : "",
					d : "",
					o : "",
					c : "",
					ps : "",
					pc : "",
					pp : "",
					sc : "",
					sq : "",
					sa : "",
					sb : "",
					se : "",
					st : "",
					spc : "",
					spqid : "",
					page : 1,
					ext : "",
					v : "D"
				},
				init : function(data) {
					this.data = _.extend(this.data, data)
				},
				send : function() {
					cClickCode(this.data.t, this.data.g, this.data.a,
							this.data.d, this.data.o, this.data.c,
							this.data.ps, this.data.pc, this.data.pp,
							this.data.sc, this.data.sq, this.data.sa,
							this.data.e, this.data.ext, this.data.tp,
							this.data.ad, this.data.spqid, this.data.sb,
							this.data.se, this.data.st, this.data.ver,
							this.data.page)
				}
			}
		}
		return {
			send : function(data) {
				if (hot_SHOP_CC != "") {
					hot_SHOP_CC.init(data);
					hot_SHOP_CC.send("")
				}
			}
		}
	});
	hottrends.clickcode = function(obj) {
		var data = {
			t : "T_mobile",
			g : "G_mobile_sh",
			a : "A_mobile_sh_issue_keyword"
		};
		data.o = jQuery(obj).attr("data-idx");
		data.sq = jQuery(obj).attr("data-keyword");
		hottrends.setClickCode().send(data)
	}
})();
(function() {
	hottrends.ShoppingCollection = hottrends.Collection
			.extend({
				init : function(el, data) {
					hottrends.assert(window.rtupcate,
							"you should define `rtupcate` global variable");
					this.name = data.grp.replace("age",
							'대 <span class="no_tab_view"> 쇼핑이슈</span>');
					this.jsonpQuery = "";
					this.data = data;
					this.el = el;
					this.collapsedCounter = 0;
					this.isNew = false
				},
				render : function(callback) {
					var self = this;
					this._getData(function(realtime) {
						var html = self._render(realtime);
						callback(html)
					})
				},
				_render : function(data) {
					var buffer = [], word;
					buffer.push('<ul class="tab_rank">');
					buffer
							.push("<li "
									+ (window.thisSex == "F" ? 'class="on"'
											: "") + ">");
					buffer
							.push('<a href="javascript:;" class="link_tab link_tab_F" onclick="hottrends.changeSubTab(this,\'F\');"><span class="ico_check"></span>여자</a>');
					buffer.push("</li>");
					buffer
							.push("<li "
									+ (window.thisSex == "M" ? 'class="on"'
											: "") + ">");
					buffer
							.push('<a href="javascript:;" class="link_tab link_tab_M" onclick="hottrends.changeSubTab(this,\'M\');"><span class="ico_check"></span>남자</a>');
					buffer.push("</li>");
					buffer.push("</ul>");
					buffer.push('<ol class="list_issue female_list" '
							+ (window.thisSex == "M" ? ' style="display:none"'
									: "") + ">");
					for (var i = 0; i < 10; i++) {
						word = data.fkeywordList[i];
						buffer.push("<li " + (i === 0 ? 'class="fst"' : "")
								+ ">");
						buffer
								.push('<a href="'
										+ this._getSearchURL(word)
										+ '" data-idx="'
										+ i
										+ '" data-keyword="'
										+ encodeURIComponent(word.text)
										+ '" onclick="hottrends.clickcode(this);" class="link_issue">');
						buffer.push('<em class="num_issue">' + (i + 1)
								+ '</em><span class="screen_out">위</span>');
						buffer.push('<span class="txt_issue">' + word.text
								+ "</span>");
						buffer.push('<em class="state_issue">');
						if (word.moverank == 9999) {
							buffer
									.push('<span class="img_g ico_new">신규진입</span>')
						} else {
							if (word.moverank > 0 && word.moverank < 18) {
								buffer
										.push('<span class="img_g ico_up">상승</span><span class="num_rank">'
												+ word.moverank + "</span>")
							} else {
								if (word.moverank >= 18) {
									buffer
											.push('<span class="img_g ico_up">상승</span><span class="num_rank">'
													+ word.moverank + "</span>")
								} else {
									if (word.moverank == 0) {
										buffer
												.push('<span class="img_g ico_stay">변동없음</span>')
									} else {
										buffer
												.push('<span class="img_g ico_down">하락</span><span class="num_rank">'
														+ (word.moverank * -1)
														+ "</span>")
									}
								}
							}
						}
						buffer.push("</em></a></li>")
					}
					buffer.push("</ol>");
					buffer.push('<ol class="list_issue male_list" '
							+ (window.thisSex == "F" ? ' style="display:none"'
									: "") + ">");
					for (var i = 0; i < 10; i++) {
						word = data.mkeywordList[i];
						buffer.push("<li " + (i === 0 ? 'class="fst"' : "")
								+ ">");
						buffer
								.push('<a href="'
										+ this._getSearchURL(word)
										+ '" data-idx="'
										+ i
										+ '" data-keyword="'
										+ encodeURIComponent(word.text)
										+ '" onclick="hottrends.clickcode(this);" class="link_issue">');
						buffer.push('<em class="num_issue">' + (i + 1)
								+ '</em><span class="screen_out">위</span>');
						buffer.push('<span class="txt_issue">' + word.text
								+ "</span>");
						buffer.push('<em class="state_issue">');
						if (word.moverank == 9999) {
							buffer
									.push('<span class="img_g ico_new">신규진입</span>')
						} else {
							if (word.moverank > 0 && word.moverank < 18) {
								buffer
										.push('<span class="img_g ico_up">상승</span><span class="num_rank">'
												+ word.moverank + "</span>")
							} else {
								if (word.moverank >= 18) {
									buffer
											.push('<span class="img_g ico_up">상승</span><span class="num_rank">'
													+ word.moverank + "</span>")
								} else {
									if (word.moverank == 0) {
										buffer
												.push('<span class="img_g ico_stay">변동없음</span>')
									} else {
										buffer
												.push('<span class="img_g ico_down">하락</span><span class="num_rank">'
														+ (word.moverank * -1)
														+ "</span>")
									}
								}
							}
						}
						buffer.push("</em></a></li>")
					}
					buffer.push("</ol>");
					return buffer.join("")
				},
				_getData : function(callback) {
					callback(this.data)
				},
				renderCollapsed : function(callback) {
					this._renderNthItem(this.collapsedCounter, callback);
					this._countUpCollapsed()
				},
				_renderNthItem : function(index, callback) {
					var self = this;
					this
							._getData(function(data) {
								var word = (window.thisSex == "M" ? data.mkeywordList[index]
										: data.fkeywordList[index]), buffer = [];
								buffer
										.push('<a href="'
												+ self._getSearchURL(word)
												+ '" data-idx="'
												+ index
												+ '" data-keyword="'
												+ encodeURIComponent(word.text)
												+ '" onclick="hottrends.clickcode(this);" class="link_issue">');
								buffer.push('<em class="num_issue">'
										+ (index + 1) + "</em>");
								buffer
										.push('<span class="screen_out">위</span>');
								buffer.push("\r\n");
								buffer.push('<span class="txt_issue">'
										+ word.text + "</span>");
								buffer.push("</a>");
								callback(buffer.join(""))
							})
				},
				_getSearchURL : function(word) {
					return "/mini/search.daum?q="
							+ encodeURIComponent(word.text)
							+ "&nil_profile=rtupkwd&rtupcate="
							+ window.rtupcate
				}
			})
})();
(function($) {
	window.defaultSetting = "";
	window.addMobileZzim = function(prodid) {
		var targetParent = $("#zzim_" + prodid).blur().parent();
		targetParent.blur();
		var subTarget = $("[data-zzimid=zzim_" + prodid + "]").parent();
		if (targetParent.hasClass("on")) {
			if (confirm("이미 찜한 상품입니다.\n찜을 해제하시겠습니까?")) {
				var url = Shopping.apis.delzzimprod;
				var data = {};
				data.prodid = prodid;
				$.ajax(
						url,
						{
							data : data,
							fail : function() {
								alert("실패하였습니다. 잠시후 다시 시도해주세요.");
								if (Backbone && Backbone.history) {
									location = document.location;
									var hash = location.hash.replace("#", "")
											.replace(/&?zzimid:\w+/, "");
									Backbone.history.navigate(hash, {
										replace : true
									})
								} else {
									document.location.hash = ""
								}
							}
						}).success(
						_.bind(function(resp) {
							if (resp.desc == "ok") {
								targetParent.removeClass("on");
								subTarget.removeClass("on");
								var count = $("#gnbZzimCount");
								if (!_.isEmpty(count)) {
									count.html(parseInt(count.html(), 10) - 1)
								}
								checkGNBInfo.blnZzimFetch = false;
								checkGNBInfo.fetchZzim()
							} else {
								alert("삭제에 실패하였습니다.\n 잠시후 다시 시도해주세요")
							}
							if (Backbone && Backbone.history) {
								location = document.location;
								var reloadFlag = false;
								if (location.href.indexOf("zzimid") > -1
										&& ua_result.browser.name == "android"
										&& ua_result.ua
												.indexOf("mobile safari") > 0) {
									reloadFlag = true
								}
								var hash = location.hash.replace("#", "")
										.replace(/&?zzimid:\w+/, "");
								Backbone.history.navigate(hash, {
									replace : true
								});
								if (reloadFlag) {
									location.reload()
								}
							} else {
								document.location.hash = ""
							}
						}, this))
			}
		} else {
			$
					.ajax({
						url : Shopping.apis.mAddZzim,
						data : {
							prodid : prodid
						}
					})
					.done(
							function(resp) {
								var reloadFlag = false;
								if (Backbone && Backbone.history) {
									location = document.location;
									if (location.href.indexOf("zzimid") > -1
											&& ua_result.browser.name == "android"
											&& ua_result.ua
													.indexOf("mobile safari") > 0) {
										reloadFlag = true
									}
									var hash = location.hash.replace("#", "")
											.replace(/&?zzimid:\w+/, "");
									Backbone.history.navigate(hash, {
										replace : true
									});
									checkGNBInfo.blnZzimFetch = false;
									checkGNBInfo.fetchZzim()
								} else {
									document.location.hash = ""
								}
								var msg = resp.msg;
								var message = "";
								if (msg != "" && msg == "EXIST") {
									message = "이미 찜하신 상품입니다.\n목록에서 확인하시겠습니까?"
								} else {
									if (msg != "" && msg == "OK") {
										message = "찜하기가 완료되었습니다.\n목록에서 확인하시겠습니까?";
										targetParent.addClass("on");
										subTarget.addClass("on")
									} else {
										if (msg != "" && msg == "SKIP") {
											message = msg
										}
									}
								}
								if (msg == "EXIST" || msg == "OK") {
									var count = $("#gnbZzimCount");
									if (!_.isEmpty(count)) {
										count
												.html(parseInt(count.html(), 10) + 1)
									}
									if (confirm(message)) {
										$(".dimmed_layer").remove();
										$(".shopping_layer").remove();
										document.location.href = MOBILEPATH
												+ "#!/my/zzim/page:1&type:product"
									} else {
										if (reloadFlag) {
											location.reload()
										}
									}
								} else {
									if (msg == "SKIP") {
									} else {
										if (msg == "login") {
											var url = document.location.href;
											if (Backbone && Backbone.history) {
												if (url.lastIndexOf(":") > 4) {
													url += "&zzimid:" + prodid
												} else {
													if (_.last(url) == "/") {
														url += "zzimid:"
																+ prodid
													} else {
														url += "/zzimid:"
																+ prodid
													}
												}
											} else {
												url += "#addzzim"
											}
											document.location.href = "https://logins.daum.net/accounts/loginform.do?mobilefull=1&url="
													+ encodeURIComponent(url)
										} else {
											alert("찜하기가 실패했습니다.\n잠시후 다시 시도해주세요.")
										}
									}
								}
							})
		}
	};
	window.getSpace = function(el, space) {
		return (el.height() - space) / 2
	};
	window.moveTop = function(e) {
		if (e) {
			e.preventDefault();
			$(e.currentTarget).blur()
		}
		$(window).scrollTop(0)
	};
	window.onlyPcLayer = function(prodid, isPlay) {
		var html = '<div class="shopping_layer info_pconly"><div class="inner_shopping"><div class="layer_body"><strong class="tit_notice">알림</strong>	<p class="desc_info">해당상품은 모바일 제휴 되지않은<br>쇼핑몰 상품입니다.<br><em class="info_notice">‘찜하기’ 후 PC로 접속</em>해보세요.<br></p><button type="button" class="btn_mark btn_layer" onclick="addMobileZzim(\''
				+ prodid
				+ '\'); false;" data-cc="a='
				+ (isPlay ? "A_nsh_mobile_play_model_tab3_zzim"
						: "A_nsh_mobile_model_tab3_zzim")
				+ '"><span class="ico_compare ico_mark" id="zzim_'
				+ prodid
				+ '" data-zzimid="zzim_'
				+ prodid
				+ '">찜하기</span></button></div><div class="layer_foot"><a href="#none" class="btn_close" onclick="closePriceDiffLayer(); return false;">닫기</a></div></div></div>';
		$("#daumWrap")
				.append(
						'<div class="dimmed_layer" style="height:100%" onclick="closePriceDiffLayer();"></div>');
		$("#daumWrap").append(html);
		$(window).off("resize:difflayer");
		$(window).on("resize:difflayer", function() {
			checkGNBInfo.trigger("check:zzim");
			$(".dimmed_layer").height($(document).outerHeight())
		});
		$(window).trigger("resize:difflayer")
	};
	window.goOutLink = function(e) {
		var target = $(e.currentTarget);
		var model = target.data("model");
		var mvalidyn = target.data("shop");
		var shopid = target.data("shopid");
		var prodid = target.attr("id");
		if (!Backbone.History.started) {
			Backbone.history.start()
		}
		if (model == "1") {
			return true
		} else {
			if (mvalidyn == "N") {
				Backbone.history.navigate("outLinkLayer");
				onlyPcLayer(item.id, false)
			} else {
				if (shopid == "11st" || shopid == "gmarket"
						|| shopid == "auction") {
					Backbone.history.navigate("outLinkLayer");
					priceDiffLayer(prodid, target.attr("href"), false, shopid)
				} else {
					return true
				}
			}
			return false
		}
	};
	window.priceDiffLayer = function(prodid, prodhref, isPlay, shopid) {
		var html = '<div class="shopping_layer"><div class="inner_shopping"><div class="layer_body"><strong class="tit_notice">알림</strong>';
		if (shopid == "11st") {
			html = html
					+ '<p class="desc_info">쇼핑하우 PC버전 판매가 입니다.<br>모바일 판매가는 다를 수 있습니다.<br><em class="info_notice">‘찜하기’ 후 PC로 접속</em>해보세요.<br></p>'
		} else {
			html = html
					+ '<p class="desc_info">해당 가격은 쇼핑하우 PC 버전에서<br>구매 가능한 쿠폰 적용가입니다.<br><em class="info_notice">‘찜하기’ 후 PC로 접속</em>해보세요.<br></p>'
		}
		html = html
				+ '<button type="button" class="btn_mark btn_layer" onclick="addMobileZzim(\''
				+ prodid
				+ '\'); false;" data-cc="a='
				+ (isPlay ? "A_nsh_mobile_play_model_tab3_zzim"
						: "A_nsh_mobile_model_tab3_zzim")
				+ '"><span class="ico_compare ico_mark" id="zzim_'
				+ prodid
				+ '" data-zzimid="zzim_'
				+ prodid
				+ '">찜하기</span></button><a href="'
				+ prodhref
				+ '" target="_blank" class="link_shoppingmall" onclick="closePriceDiffLayer();">쇼핑몰로 이동</a></div><div class="layer_foot"><a href="#none" class="btn_close" onclick="closePriceDiffLayer(); return false;">닫기</a></div></div></div>';
		$("#daumWrap")
				.append(
						'<div class="dimmed_layer" style="height:100%" onclick="closePriceDiffLayer();"></div>');
		$("#daumWrap").append(html);
		$(window).off("resize:difflayer");
		$(window).on("resize:difflayer", function() {
			checkGNBInfo.trigger("check:zzim");
			$(".dimmed_layer").height($(document).outerHeight())
		});
		$(window).trigger("resize:difflayer")
	};
	window.closePriceDiffLayer = function() {
		$(".dimmed_layer").remove();
		$(".shopping_layer").remove();
		if (Backbone.history.previousFragment) {
			Backbone.history.navigate(Backbone.history.previousFragment);
			delete Backbone.history.previousFragment
		} else {
			window.history.back()
		}
	};
	goOutLinkForMobileDetailSummaryTabView = function(prodid) {
		var target = $(e.currentTarget);
		var prodidx = target.data("prodidx");
		var item = this.model.get("searchList").list[prodidx];
		if (item.model == "1") {
			return true
		} else {
			var isPlay = !item.lastcateid.indexOf("103108");
			if (item.mvalidyn == "N") {
				Backbone.history.navigate("outLinkLayer");
				onlyPcLayer(item.id, isPlay)
			} else {
				if (item.cpId == "11st" || item.cpId == "gmarket"
						|| item.cpId == "auction") {
					Backbone.history.navigate("outLinkLayer");
					priceDiffLayer(item.id, target.attr("href"), isPlay,
							item.cpId)
				} else {
					return true
				}
			}
			return false
		}
	}
})(jQuery);